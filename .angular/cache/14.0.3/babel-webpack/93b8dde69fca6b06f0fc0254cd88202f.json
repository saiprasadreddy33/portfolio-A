{"ast":null,"code":"export default function (opts) {\n  let delimiter = opts.delimiter;\n  let delimiterRegex;\n  /* Ensure that the delimiter search variable is a non-empty string. */\n\n  if (opts.search.length && (typeof opts.search === \"string\" || /^\\d/.test(parseFloat(opts.search)))) {\n    /* Since the search is performed as a Regex (see below), we escape the string's Regex meta-characters. */\n    delimiter = opts.search.toString().replace(/[-[\\]{,}(.)*+?|^$\\\\\\/]/g, \"\\\\$&\");\n    /* Note: This matches the apostrophe+s of the phrase's possessive form: {PHRASE's}. */\n\n    /* Note: This will not match text that is part of a compound word (two words adjoined with a dash), e.g. \"front\" won't match inside \"front-end\". */\n\n    /* Note: Based on the way the search algorithm is implemented, it is not possible to search for a string that consists solely of punctuation characters. */\n\n    /* Note: By creating boundaries at Latin alphabet ranges instead of merely spaces, we effectively match phrases that are inlined alongside any type of non-Latin-letter,\n       e.g. word|, word!, ♥word♥ will all match. */\n\n    delimiterRegex = new RegExp(\"(?:^|[^-\" + characterRanges.latinLetters + \"])(\" + delimiter + \"('s)?)(?![-\" + characterRanges.latinLetters + \"])\", \"i\");\n  } else {\n    /* Normalize the string's case for the delimiter switch check below. */\n    if (typeof delimiter === \"string\") {\n      delimiter = delimiter.toLowerCase();\n    }\n\n    switch (delimiter) {\n      case \"all\":\n        /* Matches every character then later sets spaces to \"white-space: pre-line\" so they don't collapse. */\n        delimiterRegex = /(.)/;\n        break;\n\n      case \"letter\":\n      case \"char\":\n      case \"character\":\n        /* Matches every non-space character. */\n\n        /* Note: This is the slowest delimiter. However, its slowness is only noticeable when it's used on larger bodies of text (of over 500 characters) on <=IE8.\n           (Run Blast with opts.debug=true to monitor execution times.) */\n        delimiterRegex = /(\\S)/;\n        break;\n\n      case \"word\":\n        /* Matches strings in between space characters. */\n\n        /* Note: Matches will include any punctuation that's adjoined to the word, e.g. \"Hey!\" will be a full match. */\n\n        /* Note: Remember that, with Blast, every HTML element marks the start of a brand new string. Hence, \"in<b>si</b>de\" matches as three separate words. */\n        delimiterRegex = /\\s*(\\S+)\\s*/;\n        break;\n\n      case \"sentence\":\n        /* Matches phrases either ending in Latin alphabet punctuation or located at the end of the text. (Linebreaks are not considered punctuation.) */\n\n        /* Note: If you don't want punctuation to demarcate a sentence match, replace the punctuation character with {{ASCII_CODE_FOR_DESIRED_PUNCTUATION}}. ASCII codes: .={{46}}, ?={{63}}, !={{33}} */\n        delimiterRegex = /(?=\\S)(([.]{2,})?[^!?]+?([.…!?]+|(?=\\s+$)|$)(\\s*[′’'”″“\")»]+)*)/;\n        /* RegExp explanation (Tip: Use Regex101.com to play around with this expression and see which strings it matches):\n           - Expanded view: /(?=\\S) ( ([.]{2,})? [^!?]+? ([.…!?]+|(?=\\s+$)|$) (\\s*[′’'”″“\")»]+)* )\n           - (?=\\S) --> Match must contain a non-space character.\n           - ([.]{2,})? --> Match may begin with a group of periods.\n           - [^!?]+? --> Grab everything that isn't an unequivocally-terminating punctuation character, but stop at the following condition...\n           - ([.…!?]+|(?=\\s+$)|$) --> Match the last occurrence of sentence-final punctuation or the end of the text (optionally with left-side trailing spaces).\n           - (\\s*[′’'”″“\")»]+)* --> After the final punctuation, match any and all pairs of (optionally space-delimited) quotes and parentheses.\n        */\n\n        break;\n\n      case \"element\":\n        /* Matches text between HTML tags. */\n\n        /* Note: Wrapping always occurs inside of elements, i.e. <b><span class=\"blast\">Bolded text here</span></b>. */\n        delimiterRegex = /(?=\\S)([\\S\\s]*\\S)/;\n        break;\n\n      /*****************\n         Custom Regex\n      *****************/\n\n      default:\n        /* You can pass in /your-own-regex/. */\n        if (delimiter instanceof RegExp) {\n          delimiterRegex = delimiter;\n        } else {\n          console.log(NAME + \": Unrecognized delimiter, empty search string, or invalid custom Regex. Aborting.\");\n        }\n\n    }\n  }\n\n  return {\n    delimiter,\n    delimiterRegex\n  };\n}","map":{"version":3,"names":["opts","delimiter","delimiterRegex","search","length","test","parseFloat","toString","replace","RegExp","characterRanges","latinLetters","toLowerCase","console","log","NAME"],"sources":["C:/Users/saiprasad/Desktop/portfolio-angular-master/node_modules/blast-vanilla/src/createDelimiters.js"],"sourcesContent":["export default function(opts){\n    let delimiter = opts.delimiter\n    let delimiterRegex\n\n    /* Ensure that the delimiter search variable is a non-empty string. */\n    if (opts.search.length && (typeof opts.search === \"string\" || /^\\d/.test(parseFloat(opts.search)))) {\n        /* Since the search is performed as a Regex (see below), we escape the string's Regex meta-characters. */\n        delimiter = opts.search.toString().replace(/[-[\\]{,}(.)*+?|^$\\\\\\/]/g, \"\\\\$&\");\n\n        /* Note: This matches the apostrophe+s of the phrase's possessive form: {PHRASE's}. */\n        /* Note: This will not match text that is part of a compound word (two words adjoined with a dash), e.g. \"front\" won't match inside \"front-end\". */\n        /* Note: Based on the way the search algorithm is implemented, it is not possible to search for a string that consists solely of punctuation characters. */\n        /* Note: By creating boundaries at Latin alphabet ranges instead of merely spaces, we effectively match phrases that are inlined alongside any type of non-Latin-letter,\n           e.g. word|, word!, ♥word♥ will all match. */\n        delimiterRegex = new RegExp(\"(?:^|[^-\" + characterRanges.latinLetters + \"])(\" + delimiter + \"('s)?)(?![-\" + characterRanges.latinLetters + \"])\", \"i\");\n    } else {\n        /* Normalize the string's case for the delimiter switch check below. */\n        if (typeof delimiter === \"string\") {\n            delimiter = delimiter.toLowerCase();\n        }\n\n        switch (delimiter) {\n            case \"all\":\n                /* Matches every character then later sets spaces to \"white-space: pre-line\" so they don't collapse. */\n                delimiterRegex = /(.)/;\n                break;\n\n            case \"letter\":\n            case \"char\":\n            case \"character\":\n                /* Matches every non-space character. */\n                /* Note: This is the slowest delimiter. However, its slowness is only noticeable when it's used on larger bodies of text (of over 500 characters) on <=IE8.\n                   (Run Blast with opts.debug=true to monitor execution times.) */\n                delimiterRegex = /(\\S)/;\n                break;\n\n            case \"word\":\n                /* Matches strings in between space characters. */\n                /* Note: Matches will include any punctuation that's adjoined to the word, e.g. \"Hey!\" will be a full match. */\n                /* Note: Remember that, with Blast, every HTML element marks the start of a brand new string. Hence, \"in<b>si</b>de\" matches as three separate words. */\n                delimiterRegex = /\\s*(\\S+)\\s*/;\n                break;\n\n            case \"sentence\":\n                /* Matches phrases either ending in Latin alphabet punctuation or located at the end of the text. (Linebreaks are not considered punctuation.) */\n                /* Note: If you don't want punctuation to demarcate a sentence match, replace the punctuation character with {{ASCII_CODE_FOR_DESIRED_PUNCTUATION}}. ASCII codes: .={{46}}, ?={{63}}, !={{33}} */\n                delimiterRegex = /(?=\\S)(([.]{2,})?[^!?]+?([.…!?]+|(?=\\s+$)|$)(\\s*[′’'”″“\")»]+)*)/;\n                /* RegExp explanation (Tip: Use Regex101.com to play around with this expression and see which strings it matches):\n                   - Expanded view: /(?=\\S) ( ([.]{2,})? [^!?]+? ([.…!?]+|(?=\\s+$)|$) (\\s*[′’'”″“\")»]+)* )\n                   - (?=\\S) --> Match must contain a non-space character.\n                   - ([.]{2,})? --> Match may begin with a group of periods.\n                   - [^!?]+? --> Grab everything that isn't an unequivocally-terminating punctuation character, but stop at the following condition...\n                   - ([.…!?]+|(?=\\s+$)|$) --> Match the last occurrence of sentence-final punctuation or the end of the text (optionally with left-side trailing spaces).\n                   - (\\s*[′’'”″“\")»]+)* --> After the final punctuation, match any and all pairs of (optionally space-delimited) quotes and parentheses.\n                */\n                break;\n\n            case \"element\":\n                /* Matches text between HTML tags. */\n                /* Note: Wrapping always occurs inside of elements, i.e. <b><span class=\"blast\">Bolded text here</span></b>. */\n                delimiterRegex = /(?=\\S)([\\S\\s]*\\S)/;\n                break;\n\n            /*****************\n               Custom Regex\n            *****************/\n\n            default:\n                /* You can pass in /your-own-regex/. */\n                if (delimiter instanceof RegExp) {\n                    delimiterRegex = delimiter;\n                } else {\n                    console.log(NAME + \": Unrecognized delimiter, empty search string, or invalid custom Regex. Aborting.\");\n                }\n        }\n    }\n\n    return {\n        delimiter,\n        delimiterRegex\n    }\n}\n"],"mappings":"AAAA,eAAe,UAASA,IAAT,EAAc;EACzB,IAAIC,SAAS,GAAGD,IAAI,CAACC,SAArB;EACA,IAAIC,cAAJ;EAEA;;EACA,IAAIF,IAAI,CAACG,MAAL,CAAYC,MAAZ,KAAuB,OAAOJ,IAAI,CAACG,MAAZ,KAAuB,QAAvB,IAAmC,MAAME,IAAN,CAAWC,UAAU,CAACN,IAAI,CAACG,MAAN,CAArB,CAA1D,CAAJ,EAAoG;IAChG;IACAF,SAAS,GAAGD,IAAI,CAACG,MAAL,CAAYI,QAAZ,GAAuBC,OAAvB,CAA+B,yBAA/B,EAA0D,MAA1D,CAAZ;IAEA;;IACA;;IACA;;IACA;AACR;;IACQN,cAAc,GAAG,IAAIO,MAAJ,CAAW,aAAaC,eAAe,CAACC,YAA7B,GAA4C,KAA5C,GAAoDV,SAApD,GAAgE,aAAhE,GAAgFS,eAAe,CAACC,YAAhG,GAA+G,IAA1H,EAAgI,GAAhI,CAAjB;EACH,CAVD,MAUO;IACH;IACA,IAAI,OAAOV,SAAP,KAAqB,QAAzB,EAAmC;MAC/BA,SAAS,GAAGA,SAAS,CAACW,WAAV,EAAZ;IACH;;IAED,QAAQX,SAAR;MACI,KAAK,KAAL;QACI;QACAC,cAAc,GAAG,KAAjB;QACA;;MAEJ,KAAK,QAAL;MACA,KAAK,MAAL;MACA,KAAK,WAAL;QACI;;QACA;AAChB;QACgBA,cAAc,GAAG,MAAjB;QACA;;MAEJ,KAAK,MAAL;QACI;;QACA;;QACA;QACAA,cAAc,GAAG,aAAjB;QACA;;MAEJ,KAAK,UAAL;QACI;;QACA;QACAA,cAAc,GAAG,iEAAjB;QACA;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;QACgB;;MAEJ,KAAK,SAAL;QACI;;QACA;QACAA,cAAc,GAAG,mBAAjB;QACA;;MAEJ;AACZ;AACA;;MAEY;QACI;QACA,IAAID,SAAS,YAAYQ,MAAzB,EAAiC;UAC7BP,cAAc,GAAGD,SAAjB;QACH,CAFD,MAEO;UACHY,OAAO,CAACC,GAAR,CAAYC,IAAI,GAAG,mFAAnB;QACH;;IApDT;EAsDH;;EAED,OAAO;IACHd,SADG;IAEHC;EAFG,CAAP;AAIH"},"metadata":{},"sourceType":"module"}