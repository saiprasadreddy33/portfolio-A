{"ast":null,"code":"export default ((node, opts) => {\n  const wrapper = document.createElement(opts.tag);\n  /* Assign the element a class of \"blast\". */\n\n  wrapper.className = opts.name;\n  /* If a custom class was provided, assign that too. */\n\n  if (opts.customClass) {\n    wrapper.className += ' ' + opts.customClass;\n    /* If an opts.customClass is provided, generate an ID consisting of customClass and a number indicating the match's iteration. */\n\n    if (opts.generateIndexID) {\n      wrapper.id = opts.customClass + \"-\" + Element.blastedIndex;\n    }\n  }\n  /* For the \"all\" delimiter, prevent space characters from collapsing. */\n\n\n  if (opts.delimiter === \"all\" && /\\s/.test(node.data)) {\n    wrapper.style.whiteSpace = \"pre-line\";\n  }\n  /* Assign the element a class equal to its escaped inner text. Only applicable to the character and word delimiters (since they do not contain spaces). */\n\n\n  if (opts.generateValueClass === true && !opts.search && (opts.delimiter === \"character\" || opts.delimiter === \"word\")) {\n    var valueClass,\n        text = node.data;\n    /* For the word delimiter, remove adjoined punctuation, which is unlikely to be desired as part of the match -- unless the text\n       consists solely of punctuation (e.g. \"!!!\"), in which case we leave the text as-is. */\n\n    if (opts.delimiter === \"word\" && Reg.onlyContainsPunctuation.test(text)) {\n      /* E: Remove punctuation that's adjoined to either side of the word match. */\n      text = text.replace(Reg.adjoinedPunctuation, \"\");\n    }\n\n    valueClass = NAME + \"-\" + opts.delimiter.toLowerCase() + \"-\" + text.toLowerCase();\n    wrapper.className += \" \" + valueClass;\n  }\n  /* Hide the wrapper elements from screenreaders now that we've set the target's aria-label attribute. */\n\n\n  if (opts.aria) {\n    wrapper.setAttribute(\"aria-hidden\", \"true\");\n  }\n\n  wrapper.appendChild(node.cloneNode(false));\n  return wrapper;\n});","map":{"version":3,"names":["node","opts","wrapper","document","createElement","tag","className","name","customClass","generateIndexID","id","Element","blastedIndex","delimiter","test","data","style","whiteSpace","generateValueClass","search","valueClass","text","Reg","onlyContainsPunctuation","replace","adjoinedPunctuation","NAME","toLowerCase","aria","setAttribute","appendChild","cloneNode"],"sources":["C:/Users/saiprasad/Desktop/portfolio-angular-master/node_modules/blast-vanilla/src/wrapNode.js"],"sourcesContent":["export default (node, opts) => {\n    const wrapper = document.createElement(opts.tag);\n\n    /* Assign the element a class of \"blast\". */\n    wrapper.className = opts.name;\n\n    /* If a custom class was provided, assign that too. */\n    if (opts.customClass) {\n        wrapper.className += ' ' + opts.customClass;\n\n        /* If an opts.customClass is provided, generate an ID consisting of customClass and a number indicating the match's iteration. */\n        if (opts.generateIndexID) {\n            wrapper.id = opts.customClass + \"-\" + Element.blastedIndex;\n        }\n    }\n\n    /* For the \"all\" delimiter, prevent space characters from collapsing. */\n    if (opts.delimiter === \"all\" && /\\s/.test(node.data)) {\n        wrapper.style.whiteSpace = \"pre-line\";\n    }\n\n    /* Assign the element a class equal to its escaped inner text. Only applicable to the character and word delimiters (since they do not contain spaces). */\n    if (opts.generateValueClass === true && !opts.search && (opts.delimiter === \"character\" || opts.delimiter === \"word\")) {\n        var valueClass,\n            text = node.data;\n\n        /* For the word delimiter, remove adjoined punctuation, which is unlikely to be desired as part of the match -- unless the text\n           consists solely of punctuation (e.g. \"!!!\"), in which case we leave the text as-is. */\n        if (opts.delimiter === \"word\" && Reg.onlyContainsPunctuation.test(text)) {\n            /* E: Remove punctuation that's adjoined to either side of the word match. */\n            text = text.replace(Reg.adjoinedPunctuation, \"\");\n        }\n\n        valueClass = NAME + \"-\" + opts.delimiter.toLowerCase() + \"-\" + text.toLowerCase();\n\n        wrapper.className += \" \" + valueClass;\n    }\n\n    /* Hide the wrapper elements from screenreaders now that we've set the target's aria-label attribute. */\n    if (opts.aria) {\n        wrapper.setAttribute(\"aria-hidden\", \"true\");\n    }\n\n    wrapper.appendChild(node.cloneNode(false));\n\n    return wrapper;\n}\n"],"mappings":"AAAA,gBAAe,CAACA,IAAD,EAAOC,IAAP,KAAgB;EAC3B,MAAMC,OAAO,GAAGC,QAAQ,CAACC,aAAT,CAAuBH,IAAI,CAACI,GAA5B,CAAhB;EAEA;;EACAH,OAAO,CAACI,SAAR,GAAoBL,IAAI,CAACM,IAAzB;EAEA;;EACA,IAAIN,IAAI,CAACO,WAAT,EAAsB;IAClBN,OAAO,CAACI,SAAR,IAAqB,MAAML,IAAI,CAACO,WAAhC;IAEA;;IACA,IAAIP,IAAI,CAACQ,eAAT,EAA0B;MACtBP,OAAO,CAACQ,EAAR,GAAaT,IAAI,CAACO,WAAL,GAAmB,GAAnB,GAAyBG,OAAO,CAACC,YAA9C;IACH;EACJ;EAED;;;EACA,IAAIX,IAAI,CAACY,SAAL,KAAmB,KAAnB,IAA4B,KAAKC,IAAL,CAAUd,IAAI,CAACe,IAAf,CAAhC,EAAsD;IAClDb,OAAO,CAACc,KAAR,CAAcC,UAAd,GAA2B,UAA3B;EACH;EAED;;;EACA,IAAIhB,IAAI,CAACiB,kBAAL,KAA4B,IAA5B,IAAoC,CAACjB,IAAI,CAACkB,MAA1C,KAAqDlB,IAAI,CAACY,SAAL,KAAmB,WAAnB,IAAkCZ,IAAI,CAACY,SAAL,KAAmB,MAA1G,CAAJ,EAAuH;IACnH,IAAIO,UAAJ;IAAA,IACIC,IAAI,GAAGrB,IAAI,CAACe,IADhB;IAGA;AACR;;IACQ,IAAId,IAAI,CAACY,SAAL,KAAmB,MAAnB,IAA6BS,GAAG,CAACC,uBAAJ,CAA4BT,IAA5B,CAAiCO,IAAjC,CAAjC,EAAyE;MACrE;MACAA,IAAI,GAAGA,IAAI,CAACG,OAAL,CAAaF,GAAG,CAACG,mBAAjB,EAAsC,EAAtC,CAAP;IACH;;IAEDL,UAAU,GAAGM,IAAI,GAAG,GAAP,GAAazB,IAAI,CAACY,SAAL,CAAec,WAAf,EAAb,GAA4C,GAA5C,GAAkDN,IAAI,CAACM,WAAL,EAA/D;IAEAzB,OAAO,CAACI,SAAR,IAAqB,MAAMc,UAA3B;EACH;EAED;;;EACA,IAAInB,IAAI,CAAC2B,IAAT,EAAe;IACX1B,OAAO,CAAC2B,YAAR,CAAqB,aAArB,EAAoC,MAApC;EACH;;EAED3B,OAAO,CAAC4B,WAAR,CAAoB9B,IAAI,CAAC+B,SAAL,CAAe,KAAf,CAApB;EAEA,OAAO7B,OAAP;AACH,CA9CD"},"metadata":{},"sourceType":"module"}