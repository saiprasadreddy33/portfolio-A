{"ast":null,"code":"/**\n * Copyright (C) 2010-2015 Graham Breach\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * TagCanvas 2.9\n * For more information, please contact <graham@goat1000.com>\n */\n(function () {\n  \"use strict\";\n\n  var i,\n      j,\n      abs = Math.abs,\n      sin = Math.sin,\n      cos = Math.cos,\n      max = Math.max,\n      min = Math.min,\n      ceil = Math.ceil,\n      sqrt = Math.sqrt,\n      pow = Math.pow,\n      hexlookup3 = {},\n      hexlookup2 = {},\n      hexlookup1 = {\n    0: \"0,\",\n    1: \"17,\",\n    2: \"34,\",\n    3: \"51,\",\n    4: \"68,\",\n    5: \"85,\",\n    6: \"102,\",\n    7: \"119,\",\n    8: \"136,\",\n    9: \"153,\",\n    a: \"170,\",\n    A: \"170,\",\n    b: \"187,\",\n    B: \"187,\",\n    c: \"204,\",\n    C: \"204,\",\n    d: \"221,\",\n    D: \"221,\",\n    e: \"238,\",\n    E: \"238,\",\n    f: \"255,\",\n    F: \"255,\"\n  },\n      Oproto,\n      Tproto,\n      TCproto,\n      Mproto,\n      Vproto,\n      TSproto,\n      TCVproto,\n      doc = document,\n      ocanvas,\n      handlers = {};\n\n  for (i = 0; i < 256; ++i) {\n    j = i.toString(16);\n    if (i < 16) j = '0' + j;\n    hexlookup2[j] = hexlookup2[j.toUpperCase()] = i.toString() + ',';\n  }\n\n  function Defined(d) {\n    return typeof d != 'undefined';\n  }\n\n  function IsObject(o) {\n    return typeof o == 'object' && o != null;\n  }\n\n  function Clamp(v, mn, mx) {\n    return isNaN(v) ? mx : min(mx, max(mn, v));\n  }\n\n  function Nop() {\n    return false;\n  }\n\n  function TimeNow() {\n    return new Date().valueOf();\n  }\n\n  function SortList(l, f) {\n    var nl = [],\n        tl = l.length,\n        i;\n\n    for (i = 0; i < tl; ++i) nl.push(l[i]);\n\n    nl.sort(f);\n    return nl;\n  }\n\n  function Shuffle(a) {\n    var i = a.length - 1,\n        t,\n        p;\n\n    while (i) {\n      p = ~~(Math.random() * i);\n      t = a[i];\n      a[i] = a[p];\n      a[p] = t;\n      --i;\n    }\n  }\n\n  function Vector(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  Vproto = Vector.prototype;\n\n  Vproto.length = function () {\n    return sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  };\n\n  Vproto.dot = function (v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  };\n\n  Vproto.cross = function (v) {\n    var x = this.y * v.z - this.z * v.y,\n        y = this.z * v.x - this.x * v.z,\n        z = this.x * v.y - this.y * v.x;\n    return new Vector(x, y, z);\n  };\n\n  Vproto.angle = function (v) {\n    var dot = this.dot(v),\n        ac;\n    if (dot == 0) return Math.PI / 2.0;\n    ac = dot / (this.length() * v.length());\n    if (ac >= 1) return 0;\n    if (ac <= -1) return Math.PI;\n    return Math.acos(ac);\n  };\n\n  Vproto.unit = function () {\n    var l = this.length();\n    return new Vector(this.x / l, this.y / l, this.z / l);\n  };\n\n  function MakeVector(lg, lt) {\n    lt = lt * Math.PI / 180;\n    lg = lg * Math.PI / 180;\n    var x = sin(lg) * cos(lt),\n        y = -sin(lt),\n        z = -cos(lg) * cos(lt);\n    return new Vector(x, y, z);\n  }\n\n  function Matrix(a) {\n    this[1] = {\n      1: a[0],\n      2: a[1],\n      3: a[2]\n    };\n    this[2] = {\n      1: a[3],\n      2: a[4],\n      3: a[5]\n    };\n    this[3] = {\n      1: a[6],\n      2: a[7],\n      3: a[8]\n    };\n  }\n\n  Mproto = Matrix.prototype;\n\n  Matrix.Identity = function () {\n    return new Matrix([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n  };\n\n  Matrix.Rotation = function (angle, u) {\n    var sina = sin(angle),\n        cosa = cos(angle),\n        mcos = 1 - cosa;\n    return new Matrix([cosa + pow(u.x, 2) * mcos, u.x * u.y * mcos - u.z * sina, u.x * u.z * mcos + u.y * sina, u.y * u.x * mcos + u.z * sina, cosa + pow(u.y, 2) * mcos, u.y * u.z * mcos - u.x * sina, u.z * u.x * mcos - u.y * sina, u.z * u.y * mcos + u.x * sina, cosa + pow(u.z, 2) * mcos]);\n  };\n\n  Mproto.mul = function (m) {\n    var a = [],\n        i,\n        j,\n        mmatrix = m.xform ? 1 : 0;\n\n    for (i = 1; i <= 3; ++i) for (j = 1; j <= 3; ++j) {\n      if (mmatrix) a.push(this[i][1] * m[1][j] + this[i][2] * m[2][j] + this[i][3] * m[3][j]);else a.push(this[i][j] * m);\n    }\n\n    return new Matrix(a);\n  };\n\n  Mproto.xform = function (p) {\n    var a = {},\n        x = p.x,\n        y = p.y,\n        z = p.z;\n    a.x = x * this[1][1] + y * this[2][1] + z * this[3][1];\n    a.y = x * this[1][2] + y * this[2][2] + z * this[3][2];\n    a.z = x * this[1][3] + y * this[2][3] + z * this[3][3];\n    return a;\n  };\n\n  function PointsOnSphere(n, xr, yr, zr, magic) {\n    var i,\n        y,\n        r,\n        phi,\n        pts = [],\n        off = 2 / n,\n        inc;\n    inc = Math.PI * (3 - sqrt(5) + (parseFloat(magic) ? parseFloat(magic) : 0));\n\n    for (i = 0; i < n; ++i) {\n      y = i * off - 1 + off / 2;\n      r = sqrt(1 - y * y);\n      phi = i * inc;\n      pts.push([cos(phi) * r * xr, y * yr, sin(phi) * r * zr]);\n    }\n\n    return pts;\n  }\n\n  function Cylinder(n, o, xr, yr, zr, magic) {\n    var phi,\n        pts = [],\n        off = 2 / n,\n        inc,\n        i,\n        j,\n        k,\n        l;\n    inc = Math.PI * (3 - sqrt(5) + (parseFloat(magic) ? parseFloat(magic) : 0));\n\n    for (i = 0; i < n; ++i) {\n      j = i * off - 1 + off / 2;\n      phi = i * inc;\n      k = cos(phi);\n      l = sin(phi);\n      pts.push(o ? [j * xr, k * yr, l * zr] : [k * xr, j * yr, l * zr]);\n    }\n\n    return pts;\n  }\n\n  function Ring(o, n, xr, yr, zr, j) {\n    var phi,\n        pts = [],\n        inc = Math.PI * 2 / n,\n        i,\n        k,\n        l;\n\n    for (i = 0; i < n; ++i) {\n      phi = i * inc;\n      k = cos(phi);\n      l = sin(phi);\n      pts.push(o ? [j * xr, k * yr, l * zr] : [k * xr, j * yr, l * zr]);\n    }\n\n    return pts;\n  }\n\n  function PointsOnCylinderV(n, xr, yr, zr, m) {\n    return Cylinder(n, 0, xr, yr, zr, m);\n  }\n\n  function PointsOnCylinderH(n, xr, yr, zr, m) {\n    return Cylinder(n, 1, xr, yr, zr, m);\n  }\n\n  function PointsOnRingV(n, xr, yr, zr, offset) {\n    offset = isNaN(offset) ? 0 : offset * 1;\n    return Ring(0, n, xr, yr, zr, offset);\n  }\n\n  function PointsOnRingH(n, xr, yr, zr, offset) {\n    offset = isNaN(offset) ? 0 : offset * 1;\n    return Ring(1, n, xr, yr, zr, offset);\n  }\n\n  function CentreImage(t) {\n    var i = new Image();\n\n    i.onload = function () {\n      var dx = i.width / 2,\n          dy = i.height / 2;\n\n      t.centreFunc = function (c, w, h, cx, cy) {\n        c.setTransform(1, 0, 0, 1, 0, 0);\n        c.globalAlpha = 1;\n        c.drawImage(i, cx - dx, cy - dy);\n      };\n    };\n\n    i.src = t.centreImage;\n  }\n\n  function SetAlpha(c, a) {\n    var d = c,\n        p1,\n        p2,\n        ae = (a * 1).toPrecision(3) + ')';\n\n    if (c[0] === '#') {\n      if (!hexlookup3[c]) if (c.length === 4) hexlookup3[c] = 'rgba(' + hexlookup1[c[1]] + hexlookup1[c[2]] + hexlookup1[c[3]];else hexlookup3[c] = 'rgba(' + hexlookup2[c.substr(1, 2)] + hexlookup2[c.substr(3, 2)] + hexlookup2[c.substr(5, 2)];\n      d = hexlookup3[c] + ae;\n    } else if (c.substr(0, 4) === 'rgb(' || c.substr(0, 4) === 'hsl(') {\n      d = c.replace('(', 'a(').replace(')', ',' + ae);\n    } else if (c.substr(0, 5) === 'rgba(' || c.substr(0, 5) === 'hsla(') {\n      p1 = c.lastIndexOf(',') + 1, p2 = c.indexOf(')');\n      a *= parseFloat(c.substring(p1, p2));\n      d = c.substr(0, p1) + a.toPrecision(3) + ')';\n    }\n\n    return d;\n  }\n\n  function NewCanvas(w, h) {\n    // if using excanvas, give up now\n    if (window.G_vmlCanvasManager) return null;\n    var c = doc.createElement('canvas');\n    c.width = w;\n    c.height = h;\n    return c;\n  } // I think all browsers pass this test now...\n\n\n  function ShadowAlphaBroken() {\n    var cv = NewCanvas(3, 3),\n        c,\n        i;\n    if (!cv) return false;\n    c = cv.getContext('2d');\n    c.strokeStyle = '#000';\n    c.shadowColor = '#fff';\n    c.shadowBlur = 3;\n    c.globalAlpha = 0;\n    c.strokeRect(2, 2, 2, 2);\n    c.globalAlpha = 1;\n    i = c.getImageData(2, 2, 1, 1);\n    cv = null;\n    return i.data[0] > 0;\n  }\n\n  function SetGradient(c, l, o, g) {\n    var gd = c.createLinearGradient(0, 0, l, 0),\n        i;\n\n    for (i in g) gd.addColorStop(1 - i, g[i]);\n\n    c.fillStyle = gd;\n    c.fillRect(0, o, l, 1);\n  }\n\n  function FindGradientColour(tc, p, r) {\n    var l = 1024,\n        h = 1,\n        gl = tc.weightGradient,\n        cv,\n        c,\n        i,\n        d;\n\n    if (tc.gCanvas) {\n      c = tc.gCanvas.getContext('2d');\n      h = tc.gCanvas.height;\n    } else {\n      if (IsObject(gl[0])) h = gl.length;else gl = [gl];\n      tc.gCanvas = cv = NewCanvas(l, h);\n      if (!cv) return null;\n      c = cv.getContext('2d');\n\n      for (i = 0; i < h; ++i) SetGradient(c, l, i, gl[i]);\n    }\n\n    r = max(min(r || 0, h - 1), 0);\n    d = c.getImageData(~~((l - 1) * p), r, 1, 1).data;\n    return 'rgba(' + d[0] + ',' + d[1] + ',' + d[2] + ',' + d[3] / 255 + ')';\n  }\n\n  function TextSet(ctxt, font, colour, strings, padx, pady, shadowColour, shadowBlur, shadowOffsets, maxWidth, widths, align) {\n    var xo = padx + (shadowBlur || 0) + (shadowOffsets.length && shadowOffsets[0] < 0 ? abs(shadowOffsets[0]) : 0),\n        yo = pady + (shadowBlur || 0) + (shadowOffsets.length && shadowOffsets[1] < 0 ? abs(shadowOffsets[1]) : 0),\n        i,\n        xc;\n    ctxt.font = font;\n    ctxt.textBaseline = 'top';\n    ctxt.fillStyle = colour;\n    shadowColour && (ctxt.shadowColor = shadowColour);\n    shadowBlur && (ctxt.shadowBlur = shadowBlur);\n    shadowOffsets.length && (ctxt.shadowOffsetX = shadowOffsets[0], ctxt.shadowOffsetY = shadowOffsets[1]);\n\n    for (i = 0; i < strings.length; ++i) {\n      xc = 0;\n\n      if (widths) {\n        if ('right' == align) {\n          xc = maxWidth - widths[i];\n        } else if ('centre' == align) {\n          xc = (maxWidth - widths[i]) / 2;\n        }\n      }\n\n      ctxt.fillText(strings[i], xo + xc, yo);\n      yo += parseInt(font);\n    }\n  }\n\n  function RRect(c, x, y, w, h, r, s) {\n    if (r) {\n      c.beginPath();\n      c.moveTo(x, y + h - r);\n      c.arcTo(x, y, x + r, y, r);\n      c.arcTo(x + w, y, x + w, y + r, r);\n      c.arcTo(x + w, y + h, x + w - r, y + h, r);\n      c.arcTo(x, y + h, x, y + h - r, r);\n      c.closePath();\n      c[s ? 'stroke' : 'fill']();\n    } else {\n      c[s ? 'strokeRect' : 'fillRect'](x, y, w, h);\n    }\n  }\n\n  function TextCanvas(strings, font, w, h, maxWidth, stringWidths, align, valign, scale) {\n    this.strings = strings;\n    this.font = font;\n    this.width = w;\n    this.height = h;\n    this.maxWidth = maxWidth;\n    this.stringWidths = stringWidths;\n    this.align = align;\n    this.valign = valign;\n    this.scale = scale;\n  }\n\n  TCVproto = TextCanvas.prototype;\n\n  TCVproto.SetImage = function (image, w, h, position, padding, align, valign, scale) {\n    this.image = image;\n    this.iwidth = w * this.scale;\n    this.iheight = h * this.scale;\n    this.ipos = position;\n    this.ipad = padding * this.scale;\n    this.iscale = scale;\n    this.ialign = align;\n    this.ivalign = valign;\n  };\n\n  TCVproto.Align = function (size, space, a) {\n    var pos = 0;\n    if (a == 'right' || a == 'bottom') pos = space - size;else if (a != 'left' && a != 'top') pos = (space - size) / 2;\n    return pos;\n  };\n\n  TCVproto.Create = function (colour, bgColour, bgOutline, bgOutlineThickness, shadowColour, shadowBlur, shadowOffsets, padding, radius) {\n    var cv,\n        cw,\n        ch,\n        c,\n        x1,\n        x2,\n        y1,\n        y2,\n        offx,\n        offy,\n        ix,\n        iy,\n        iw,\n        ih,\n        rr,\n        sox = abs(shadowOffsets[0]),\n        soy = abs(shadowOffsets[1]),\n        shadowcv,\n        shadowc;\n    padding = max(padding, sox + shadowBlur, soy + shadowBlur);\n    x1 = 2 * (padding + bgOutlineThickness);\n    y1 = 2 * (padding + bgOutlineThickness);\n    cw = this.width + x1;\n    ch = this.height + y1;\n    offx = offy = padding + bgOutlineThickness;\n\n    if (this.image) {\n      ix = iy = padding + bgOutlineThickness;\n      iw = this.iwidth;\n      ih = this.iheight;\n\n      if (this.ipos == 'top' || this.ipos == 'bottom') {\n        if (iw < this.width) ix += this.Align(iw, this.width, this.ialign);else offx += this.Align(this.width, iw, this.align);\n        if (this.ipos == 'top') offy += ih + this.ipad;else iy += this.height + this.ipad;\n        cw = max(cw, iw + x1);\n        ch += ih + this.ipad;\n      } else {\n        if (ih < this.height) iy += this.Align(ih, this.height, this.ivalign);else offy += this.Align(this.height, ih, this.valign);\n        if (this.ipos == 'right') ix += this.width + this.ipad;else offx += iw + this.ipad;\n        cw += iw + this.ipad;\n        ch = max(ch, ih + y1);\n      }\n    }\n\n    cv = NewCanvas(cw, ch);\n    if (!cv) return null;\n    x1 = y1 = bgOutlineThickness / 2;\n    x2 = cw - bgOutlineThickness;\n    y2 = ch - bgOutlineThickness;\n    rr = min(radius, x2 / 2, y2 / 2);\n    c = cv.getContext('2d');\n\n    if (bgColour) {\n      c.fillStyle = bgColour;\n      RRect(c, x1, y1, x2, y2, rr);\n    }\n\n    if (bgOutlineThickness) {\n      c.strokeStyle = bgOutline;\n      c.lineWidth = bgOutlineThickness;\n      RRect(c, x1, y1, x2, y2, rr, true);\n    }\n\n    if (shadowBlur || sox || soy) {\n      // use a transparent canvas to draw on\n      shadowcv = NewCanvas(cw, ch);\n\n      if (shadowcv) {\n        shadowc = c;\n        c = shadowcv.getContext('2d');\n      }\n    } // don't use TextSet shadow support because it adds space for shadow\n\n\n    TextSet(c, this.font, colour, this.strings, offx, offy, 0, 0, [], this.maxWidth, this.stringWidths, this.align);\n    if (this.image) c.drawImage(this.image, ix, iy, iw, ih);\n\n    if (shadowc) {\n      // draw the text and image with the added shadow\n      c = shadowc;\n      shadowColour && (c.shadowColor = shadowColour);\n      shadowBlur && (c.shadowBlur = shadowBlur);\n      c.shadowOffsetX = shadowOffsets[0];\n      c.shadowOffsetY = shadowOffsets[1];\n      c.drawImage(shadowcv, 0, 0);\n    }\n\n    return cv;\n  };\n\n  function ExpandImage(i, w, h) {\n    var cv = NewCanvas(w, h),\n        c;\n    if (!cv) return null;\n    c = cv.getContext('2d');\n    c.drawImage(i, (w - i.width) / 2, (h - i.height) / 2);\n    return cv;\n  }\n\n  function ScaleImage(i, w, h) {\n    var cv = NewCanvas(w, h),\n        c;\n    if (!cv) return null;\n    c = cv.getContext('2d');\n    c.drawImage(i, 0, 0, w, h);\n    return cv;\n  }\n\n  function AddBackgroundToImage(i, w, h, scale, colour, othickness, ocolour, padding, radius, ofill) {\n    var cw = w + (2 * padding + othickness) * scale,\n        ch = h + (2 * padding + othickness) * scale,\n        cv = NewCanvas(cw, ch),\n        c,\n        x1,\n        y1,\n        x2,\n        y2,\n        ocanvas,\n        cc,\n        rr;\n    if (!cv) return null;\n    othickness *= scale;\n    radius *= scale;\n    x1 = y1 = othickness / 2;\n    x2 = cw - othickness;\n    y2 = ch - othickness;\n    padding = padding * scale + x1; // add space for outline\n\n    c = cv.getContext('2d');\n    rr = min(radius, x2 / 2, y2 / 2);\n\n    if (colour) {\n      c.fillStyle = colour;\n      RRect(c, x1, y1, x2, y2, rr);\n    }\n\n    if (othickness) {\n      c.strokeStyle = ocolour;\n      c.lineWidth = othickness;\n      RRect(c, x1, y1, x2, y2, rr, true);\n    }\n\n    if (ofill) {\n      // use compositing to colour in the image and border\n      ocanvas = NewCanvas(cw, ch);\n      cc = ocanvas.getContext('2d');\n      cc.drawImage(i, padding, padding, w, h);\n      cc.globalCompositeOperation = 'source-in';\n      cc.fillStyle = ocolour;\n      cc.fillRect(0, 0, cw, ch);\n      cc.globalCompositeOperation = 'destination-over';\n      cc.drawImage(cv, 0, 0);\n      cc.globalCompositeOperation = 'source-over';\n      c.drawImage(ocanvas, 0, 0);\n    } else {\n      c.drawImage(i, padding, padding, i.width, i.height);\n    }\n\n    return {\n      image: cv,\n      width: cw / scale,\n      height: ch / scale\n    };\n  }\n  /**\n   * Rounds off the corners of an image\n   */\n\n\n  function RoundImage(i, r, iw, ih, s) {\n    var cv,\n        c,\n        r1 = parseFloat(r),\n        l = max(iw, ih);\n    cv = NewCanvas(iw, ih);\n    if (!cv) return null;\n    if (r.indexOf('%') > 0) r1 = l * r1 / 100;else r1 = r1 * s;\n    c = cv.getContext('2d');\n    c.globalCompositeOperation = 'source-over';\n    c.fillStyle = '#fff';\n\n    if (r1 >= l / 2) {\n      r1 = min(iw, ih) / 2;\n      c.beginPath();\n      c.moveTo(iw / 2, ih / 2);\n      c.arc(iw / 2, ih / 2, r1, 0, 2 * Math.PI, false);\n      c.fill();\n      c.closePath();\n    } else {\n      r1 = min(iw / 2, ih / 2, r1);\n      RRect(c, 0, 0, iw, ih, r1, true);\n      c.fill();\n    }\n\n    c.globalCompositeOperation = 'source-in';\n    c.drawImage(i, 0, 0, iw, ih);\n    return cv;\n  }\n  /**\n   * Creates a new canvas containing the image and its shadow\n   * Returns an object containing the image and its dimensions at z=0\n   */\n\n\n  function AddShadowToImage(i, w, h, scale, sc, sb, so) {\n    var sw = abs(so[0]),\n        sh = abs(so[1]),\n        cw = w + (sw > sb ? sw + sb : sb * 2) * scale,\n        ch = h + (sh > sb ? sh + sb : sb * 2) * scale,\n        xo = scale * ((sb || 0) + (so[0] < 0 ? sw : 0)),\n        yo = scale * ((sb || 0) + (so[1] < 0 ? sh : 0)),\n        cv,\n        c;\n    cv = NewCanvas(cw, ch);\n    if (!cv) return null;\n    c = cv.getContext('2d');\n    sc && (c.shadowColor = sc);\n    sb && (c.shadowBlur = sb * scale);\n    so && (c.shadowOffsetX = so[0] * scale, c.shadowOffsetY = so[1] * scale);\n    c.drawImage(i, xo, yo, w, h);\n    return {\n      image: cv,\n      width: cw / scale,\n      height: ch / scale\n    };\n  }\n\n  function FindTextBoundingBox(s, f, ht) {\n    var w = parseInt(s.toString().length * ht),\n        h = parseInt(ht * 2 * s.length),\n        cv = NewCanvas(w, h),\n        c,\n        idata,\n        w1,\n        h1,\n        x,\n        y,\n        i,\n        ex;\n    if (!cv) return null;\n    c = cv.getContext('2d');\n    c.fillStyle = '#000';\n    c.fillRect(0, 0, w, h);\n    TextSet(c, ht + 'px ' + f, '#fff', s, 0, 0, 0, 0, [], 'centre');\n    idata = c.getImageData(0, 0, w, h);\n    w1 = idata.width;\n    h1 = idata.height;\n    ex = {\n      min: {\n        x: w1,\n        y: h1\n      },\n      max: {\n        x: -1,\n        y: -1\n      }\n    };\n\n    for (y = 0; y < h1; ++y) {\n      for (x = 0; x < w1; ++x) {\n        i = (y * w1 + x) * 4;\n\n        if (idata.data[i + 1] > 0) {\n          if (x < ex.min.x) ex.min.x = x;\n          if (x > ex.max.x) ex.max.x = x;\n          if (y < ex.min.y) ex.min.y = y;\n          if (y > ex.max.y) ex.max.y = y;\n        }\n      }\n    } // device pixels might not be css pixels\n\n\n    if (w1 != w) {\n      ex.min.x *= w / w1;\n      ex.max.x *= w / w1;\n    }\n\n    if (h1 != h) {\n      ex.min.y *= w / h1;\n      ex.max.y *= w / h1;\n    }\n\n    cv = null;\n    return ex;\n  }\n\n  function FixFont(f) {\n    return \"'\" + f.replace(/(\\'|\\\")/g, '').replace(/\\s*,\\s*/g, \"', '\") + \"'\";\n  }\n\n  function AddHandler(h, f, e) {\n    e = e || doc;\n    if (e.addEventListener) e.addEventListener(h, f, false);else e.attachEvent('on' + h, f);\n  }\n\n  function RemoveHandler(h, f, e) {\n    e = e || doc;\n    if (e.removeEventListener) e.removeEventListener(h, f);else e.detachEvent('on' + h, f);\n  }\n\n  function AddImage(i, o, t, tc) {\n    var s = tc.imageScale,\n        mscale,\n        ic,\n        bc,\n        oc,\n        iw,\n        ih; // image not loaded, wait for image onload\n\n    if (!o.complete) return AddHandler('load', function () {\n      AddImage(i, o, t, tc);\n    }, o);\n    if (!i.complete) return AddHandler('load', function () {\n      AddImage(i, o, t, tc);\n    }, i); // Yes, this does look like nonsense, but it makes sure that both the\n    // width and height are actually set and not just calculated. This is\n    // required to keep proportional sizes when the images are hidden, so\n    // the images can be used again for another cloud.\n\n    o.width = o.width;\n    o.height = o.height;\n\n    if (s) {\n      i.width = o.width * s;\n      i.height = o.height * s;\n    } // the standard width of the image, with imageScale applied\n\n\n    t.iw = i.width;\n    t.ih = i.height;\n\n    if (tc.txtOpt) {\n      ic = i;\n      mscale = tc.zoomMax * tc.txtScale;\n      iw = t.iw * mscale;\n      ih = t.ih * mscale;\n\n      if (iw < o.naturalWidth || ih < o.naturalHeight) {\n        ic = ScaleImage(i, iw, ih);\n        if (ic) t.fimage = ic;\n      } else {\n        iw = t.iw;\n        ih = t.ih;\n        mscale = 1;\n      }\n\n      if (parseFloat(tc.imageRadius)) t.image = t.fimage = i = RoundImage(t.image, tc.imageRadius, iw, ih, mscale);\n\n      if (!t.HasText()) {\n        if (tc.shadow) {\n          ic = AddShadowToImage(t.image, iw, ih, mscale, tc.shadow, tc.shadowBlur, tc.shadowOffset);\n\n          if (ic) {\n            t.fimage = ic.image;\n            t.w = ic.width;\n            t.h = ic.height;\n          }\n        }\n\n        if (tc.bgColour || tc.bgOutlineThickness) {\n          bc = tc.bgColour == 'tag' ? GetProperty(t.a, 'background-color') : tc.bgColour;\n          oc = tc.bgOutline == 'tag' ? GetProperty(t.a, 'color') : tc.bgOutline || tc.textColour;\n          iw = t.fimage.width;\n          ih = t.fimage.height;\n\n          if (tc.outlineMethod == 'colour') {\n            // create the outline version first, using the current image state\n            ic = AddBackgroundToImage(t.fimage, iw, ih, mscale, bc, tc.bgOutlineThickness, t.outline.colour, tc.padding, tc.bgRadius, 1);\n            if (ic) t.oimage = ic.image;\n          }\n\n          ic = AddBackgroundToImage(t.fimage, iw, ih, mscale, bc, tc.bgOutlineThickness, oc, tc.padding, tc.bgRadius);\n\n          if (ic) {\n            t.fimage = ic.image;\n            t.w = ic.width;\n            t.h = ic.height;\n          }\n        }\n\n        if (tc.outlineMethod == 'size') {\n          if (tc.outlineIncrease > 0) {\n            t.iw += 2 * tc.outlineIncrease;\n            t.ih += 2 * tc.outlineIncrease;\n            iw = mscale * t.iw;\n            ih = mscale * t.ih;\n            ic = ScaleImage(t.fimage, iw, ih);\n            t.oimage = ic;\n            t.fimage = ExpandImage(t.fimage, t.oimage.width, t.oimage.height);\n          } else {\n            iw = mscale * (t.iw + 2 * tc.outlineIncrease);\n            ih = mscale * (t.ih + 2 * tc.outlineIncrease);\n            ic = ScaleImage(t.fimage, iw, ih);\n            t.oimage = ExpandImage(ic, t.fimage.width, t.fimage.height);\n          }\n        }\n      }\n    }\n\n    t.Init();\n  }\n\n  function GetProperty(e, p) {\n    var dv = doc.defaultView,\n        pc = p.replace(/\\-([a-z])/g, function (a) {\n      return a.charAt(1).toUpperCase();\n    });\n    return dv && dv.getComputedStyle && dv.getComputedStyle(e, null).getPropertyValue(p) || e.currentStyle && e.currentStyle[pc];\n  }\n\n  function FindWeight(a, wFrom, tHeight) {\n    var w = 1,\n        p;\n\n    if (wFrom) {\n      w = 1 * (a.getAttribute(wFrom) || tHeight);\n    } else if (p = GetProperty(a, 'font-size')) {\n      w = p.indexOf('px') > -1 && p.replace('px', '') * 1 || p.indexOf('pt') > -1 && p.replace('pt', '') * 1.25 || p * 3.3;\n    }\n\n    return w;\n  }\n\n  function EventToCanvasId(e) {\n    return e.target && Defined(e.target.id) ? e.target.id : e.srcElement.parentNode.id;\n  }\n\n  function EventXY(e, c) {\n    var xy,\n        p,\n        xmul = parseInt(GetProperty(c, 'width')) / c.width,\n        ymul = parseInt(GetProperty(c, 'height')) / c.height;\n\n    if (Defined(e.offsetX)) {\n      xy = {\n        x: e.offsetX,\n        y: e.offsetY\n      };\n    } else {\n      p = AbsPos(c.id);\n      if (Defined(e.changedTouches)) e = e.changedTouches[0];\n      if (e.pageX) xy = {\n        x: e.pageX - p.x,\n        y: e.pageY - p.y\n      };\n    }\n\n    if (xy && xmul && ymul) {\n      xy.x /= xmul;\n      xy.y /= ymul;\n    }\n\n    return xy;\n  }\n\n  function MouseOut(e) {\n    var cv = e.target || e.fromElement.parentNode,\n        tc = TagCanvas.tc[cv.id];\n\n    if (tc) {\n      tc.mx = tc.my = -1;\n      tc.UnFreeze();\n      tc.EndDrag();\n    }\n  }\n\n  function MouseMove(e) {\n    var i,\n        t = TagCanvas,\n        tc,\n        p,\n        tg = EventToCanvasId(e);\n\n    for (i in t.tc) {\n      tc = t.tc[i];\n\n      if (tc.tttimer) {\n        clearTimeout(tc.tttimer);\n        tc.tttimer = null;\n      }\n    }\n\n    if (tg && t.tc[tg]) {\n      tc = t.tc[tg];\n\n      if (p = EventXY(e, tc.canvas)) {\n        tc.mx = p.x;\n        tc.my = p.y;\n        tc.Drag(e, p);\n      }\n\n      tc.drawn = 0;\n    }\n  }\n\n  function MouseDown(e) {\n    var t = TagCanvas,\n        cb = doc.addEventListener ? 0 : 1,\n        tg = EventToCanvasId(e);\n\n    if (tg && e.button == cb && t.tc[tg]) {\n      t.tc[tg].BeginDrag(e);\n    }\n  }\n\n  function MouseUp(e) {\n    var t = TagCanvas,\n        cb = doc.addEventListener ? 0 : 1,\n        tg = EventToCanvasId(e),\n        tc;\n\n    if (tg && e.button == cb && t.tc[tg]) {\n      tc = t.tc[tg];\n      MouseMove(e);\n      if (!tc.EndDrag() && !tc.touchState) tc.Clicked(e);\n    }\n  }\n\n  function TouchDown(e) {\n    var tg = EventToCanvasId(e),\n        tc = tg && TagCanvas.tc[tg],\n        p;\n\n    if (tc && e.changedTouches) {\n      if (e.touches.length == 1 && tc.touchState == 0) {\n        tc.touchState = 1;\n        tc.BeginDrag(e);\n\n        if (p = EventXY(e, tc.canvas)) {\n          tc.mx = p.x;\n          tc.my = p.y;\n          tc.drawn = 0;\n        }\n      } else if (e.targetTouches.length == 2 && tc.pinchZoom) {\n        tc.touchState = 3;\n        tc.EndDrag();\n        tc.BeginPinch(e);\n      } else {\n        tc.EndDrag();\n        tc.EndPinch();\n        tc.touchState = 0;\n      }\n    }\n  }\n\n  function TouchUp(e) {\n    var tg = EventToCanvasId(e),\n        tc = tg && TagCanvas.tc[tg];\n\n    if (tc && e.changedTouches) {\n      switch (tc.touchState) {\n        case 1:\n          tc.Draw();\n          tc.Clicked();\n          break;\n\n        case 2:\n          tc.EndDrag();\n          break;\n\n        case 3:\n          tc.EndPinch();\n      }\n\n      tc.touchState = 0;\n    }\n  }\n\n  function TouchMove(e) {\n    var i,\n        t = TagCanvas,\n        tc,\n        p,\n        tg = EventToCanvasId(e);\n\n    for (i in t.tc) {\n      tc = t.tc[i];\n\n      if (tc.tttimer) {\n        clearTimeout(tc.tttimer);\n        tc.tttimer = null;\n      }\n    }\n\n    tc = tg && t.tc[tg];\n\n    if (tc && e.changedTouches && tc.touchState) {\n      switch (tc.touchState) {\n        case 1:\n        case 2:\n          if (p = EventXY(e, tc.canvas)) {\n            tc.mx = p.x;\n            tc.my = p.y;\n            if (tc.Drag(e, p)) tc.touchState = 2;\n          }\n\n          break;\n\n        case 3:\n          tc.Pinch(e);\n      }\n\n      tc.drawn = 0;\n    }\n  }\n\n  function MouseWheel(e) {\n    var t = TagCanvas,\n        tg = EventToCanvasId(e);\n\n    if (tg && t.tc[tg]) {\n      e.cancelBubble = true;\n      e.returnValue = false;\n      e.preventDefault && e.preventDefault();\n      t.tc[tg].Wheel((e.wheelDelta || e.detail) > 0);\n    }\n  }\n\n  function Scroll(e) {\n    var i,\n        t = TagCanvas;\n    clearTimeout(t.scrollTimer);\n\n    for (i in t.tc) {\n      t.tc[i].Pause();\n    }\n\n    t.scrollTimer = setTimeout(function () {\n      var i,\n          t = TagCanvas;\n\n      for (i in t.tc) {\n        t.tc[i].Resume();\n      }\n    }, t.scrollPause);\n  }\n\n  function DrawCanvas() {\n    DrawCanvasRAF(TimeNow());\n  }\n\n  function DrawCanvasRAF(t) {\n    var tc = TagCanvas.tc,\n        i;\n    TagCanvas.NextFrame(TagCanvas.interval);\n    t = t || TimeNow();\n\n    for (i in tc) tc[i].Draw(t);\n  }\n\n  function AbsPos(id) {\n    var e = doc.getElementById(id),\n        r = e.getBoundingClientRect(),\n        dd = doc.documentElement,\n        b = doc.body,\n        w = window,\n        xs = w.pageXOffset || dd.scrollLeft,\n        ys = w.pageYOffset || dd.scrollTop,\n        xo = dd.clientLeft || b.clientLeft,\n        yo = dd.clientTop || b.clientTop;\n    return {\n      x: r.left + xs - xo,\n      y: r.top + ys - yo\n    };\n  }\n\n  function Project(tc, p1, sx, sy) {\n    var m = tc.radius * tc.z1 / (tc.z1 + tc.z2 + p1.z);\n    return {\n      x: p1.x * m * sx,\n      y: p1.y * m * sy,\n      z: p1.z,\n      w: (tc.z1 - p1.z) / tc.z2\n    };\n  }\n  /**\n   * @constructor\n   * for recursively splitting tag contents on <br> tags\n   */\n\n\n  function TextSplitter(e) {\n    this.e = e;\n    this.br = 0;\n    this.line = [];\n    this.text = [];\n    this.original = e.innerText || e.textContent;\n  }\n\n  TSproto = TextSplitter.prototype;\n\n  TSproto.Empty = function () {\n    for (var i = 0; i < this.text.length; ++i) if (this.text[i].length) return false;\n\n    return true;\n  };\n\n  TSproto.Lines = function (e) {\n    var r = e ? 1 : 0,\n        cn,\n        cl,\n        i;\n    e = e || this.e;\n    cn = e.childNodes;\n    cl = cn.length;\n\n    for (i = 0; i < cl; ++i) {\n      if (cn[i].nodeName == 'BR') {\n        this.text.push(this.line.join(' '));\n        this.br = 1;\n      } else if (cn[i].nodeType == 3) {\n        if (this.br) {\n          this.line = [cn[i].nodeValue];\n          this.br = 0;\n        } else {\n          this.line.push(cn[i].nodeValue);\n        }\n      } else {\n        this.Lines(cn[i]);\n      }\n    }\n\n    r || this.br || this.text.push(this.line.join(' '));\n    return this.text;\n  };\n\n  TSproto.SplitWidth = function (w, c, f, h) {\n    var i,\n        j,\n        words,\n        text = [];\n    c.font = h + 'px ' + f;\n\n    for (i = 0; i < this.text.length; ++i) {\n      words = this.text[i].split(/\\s+/);\n      this.line = [words[0]];\n\n      for (j = 1; j < words.length; ++j) {\n        if (c.measureText(this.line.join(' ') + ' ' + words[j]).width > w) {\n          text.push(this.line.join(' '));\n          this.line = [words[j]];\n        } else {\n          this.line.push(words[j]);\n        }\n      }\n\n      text.push(this.line.join(' '));\n    }\n\n    return this.text = text;\n  };\n  /**\n   * @constructor\n   */\n\n\n  function Outline(tc, t) {\n    this.ts = null;\n    this.tc = tc;\n    this.tag = t;\n    this.x = this.y = this.w = this.h = this.sc = 1;\n    this.z = 0;\n    this.pulse = 1;\n    this.pulsate = tc.pulsateTo < 1;\n    this.colour = tc.outlineColour;\n    this.adash = ~~tc.outlineDash;\n    this.agap = ~~tc.outlineDashSpace || this.adash;\n    this.aspeed = tc.outlineDashSpeed * 1;\n    if (this.colour == 'tag') this.colour = GetProperty(t.a, 'color');else if (this.colour == 'tagbg') this.colour = GetProperty(t.a, 'background-color');\n    this.Draw = this.pulsate ? this.DrawPulsate : this.DrawSimple;\n    this.radius = tc.outlineRadius | 0;\n    this.SetMethod(tc.outlineMethod);\n  }\n\n  Oproto = Outline.prototype;\n\n  Oproto.SetMethod = function (om) {\n    var methods = {\n      block: ['PreDraw', 'DrawBlock'],\n      colour: ['PreDraw', 'DrawColour'],\n      outline: ['PostDraw', 'DrawOutline'],\n      classic: ['LastDraw', 'DrawOutline'],\n      size: ['PreDraw', 'DrawSize'],\n      none: ['LastDraw']\n    },\n        funcs = methods[om] || methods.outline;\n\n    if (om == 'none') {\n      this.Draw = function () {\n        return 1;\n      };\n    } else {\n      this.drawFunc = this[funcs[1]];\n    }\n\n    this[funcs[0]] = this.Draw;\n  };\n\n  Oproto.Update = function (x, y, w, h, sc, z, xo, yo) {\n    var o = this.tc.outlineOffset,\n        o2 = 2 * o;\n    this.x = sc * x + xo - o;\n    this.y = sc * y + yo - o;\n    this.w = sc * w + o2;\n    this.h = sc * h + o2;\n    this.sc = sc; // used to determine frontmost\n\n    this.z = z;\n  };\n\n  Oproto.Ants = function (c) {\n    if (!this.adash) return;\n    var l = this.adash,\n        g = this.agap,\n        s = this.aspeed,\n        length = l + g,\n        l1 = 0,\n        l2 = l,\n        g1 = g,\n        g2 = 0,\n        seq = 0,\n        ants;\n\n    if (s) {\n      seq = abs(s) * (TimeNow() - this.ts) / 50;\n      if (s < 0) seq = 8.64e6 - seq;\n      s = ~~seq % length;\n    }\n\n    if (s) {\n      if (l >= s) {\n        l1 = l - s;\n        l2 = s;\n      } else {\n        g1 = length - s;\n        g2 = g - g1;\n      }\n\n      ants = [l1, g1, l2, g2];\n    } else {\n      ants = [l, g];\n    }\n\n    c.setLineDash(ants);\n  };\n\n  Oproto.DrawOutline = function (c, x, y, w, h, colour) {\n    var r = min(this.radius, h / 2, w / 2);\n    c.strokeStyle = colour;\n    this.Ants(c);\n    RRect(c, x, y, w, h, r, true);\n  };\n\n  Oproto.DrawSize = function (c, x, y, w, h, colour, tag, x1, y1) {\n    var tw = tag.w,\n        th = tag.h,\n        m,\n        i,\n        sc;\n\n    if (this.pulsate) {\n      if (tag.image) sc = (tag.image.height + this.tc.outlineIncrease) / tag.image.height;else sc = tag.oscale;\n      i = tag.fimage || tag.image;\n      m = 1 + (sc - 1) * (1 - this.pulse);\n      tag.h *= m;\n      tag.w *= m;\n    } else {\n      i = tag.oimage;\n    }\n\n    tag.alpha = 1;\n    tag.Draw(c, x1, y1, i);\n    tag.h = th;\n    tag.w = tw;\n    return 1;\n  };\n\n  Oproto.DrawColour = function (c, x, y, w, h, colour, tag, x1, y1) {\n    if (tag.oimage) {\n      if (this.pulse < 1) {\n        tag.alpha = 1 - pow(this.pulse, 2);\n        tag.Draw(c, x1, y1, tag.fimage);\n        tag.alpha = this.pulse;\n      } else {\n        tag.alpha = 1;\n      }\n\n      tag.Draw(c, x1, y1, tag.oimage);\n      return 1;\n    }\n\n    return this[tag.image ? 'DrawColourImage' : 'DrawColourText'](c, x, y, w, h, colour, tag, x1, y1);\n  };\n\n  Oproto.DrawColourText = function (c, x, y, w, h, colour, tag, x1, y1) {\n    var normal = tag.colour;\n    tag.colour = colour;\n    tag.alpha = 1;\n    tag.Draw(c, x1, y1);\n    tag.colour = normal;\n    return 1;\n  };\n\n  Oproto.DrawColourImage = function (c, x, y, w, h, colour, tag, x1, y1) {\n    var ccanvas = c.canvas,\n        fx = ~~max(x, 0),\n        fy = ~~max(y, 0),\n        fw = min(ccanvas.width - fx, w) + .5 | 0,\n        fh = min(ccanvas.height - fy, h) + .5 | 0,\n        cc;\n    if (ocanvas) ocanvas.width = fw, ocanvas.height = fh;else ocanvas = NewCanvas(fw, fh);\n    if (!ocanvas) return this.SetMethod('outline'); // if using IE and images, give up!\n\n    cc = ocanvas.getContext('2d');\n    cc.drawImage(ccanvas, fx, fy, fw, fh, 0, 0, fw, fh);\n    c.clearRect(fx, fy, fw, fh);\n\n    if (this.pulsate) {\n      tag.alpha = 1 - pow(this.pulse, 2);\n    } else {\n      tag.alpha = 1;\n    }\n\n    tag.Draw(c, x1, y1);\n    c.setTransform(1, 0, 0, 1, 0, 0);\n    c.save();\n    c.beginPath();\n    c.rect(fx, fy, fw, fh);\n    c.clip();\n    c.globalCompositeOperation = 'source-in';\n    c.fillStyle = colour;\n    c.fillRect(fx, fy, fw, fh);\n    c.restore();\n    c.globalAlpha = 1;\n    c.globalCompositeOperation = 'destination-over';\n    c.drawImage(ocanvas, 0, 0, fw, fh, fx, fy, fw, fh);\n    c.globalCompositeOperation = 'source-over';\n    return 1;\n  };\n\n  Oproto.DrawBlock = function (c, x, y, w, h, colour) {\n    var r = min(this.radius, h / 2, w / 2);\n    c.fillStyle = colour;\n    RRect(c, x, y, w, h, r);\n  };\n\n  Oproto.DrawSimple = function (c, tag, x1, y1, ga, useGa) {\n    var t = this.tc;\n    c.setTransform(1, 0, 0, 1, 0, 0);\n    c.strokeStyle = this.colour;\n    c.lineWidth = t.outlineThickness;\n    c.shadowBlur = c.shadowOffsetX = c.shadowOffsetY = 0;\n    c.globalAlpha = useGa ? ga : 1;\n    return this.drawFunc(c, this.x, this.y, this.w, this.h, this.colour, tag, x1, y1);\n  };\n\n  Oproto.DrawPulsate = function (c, tag, x1, y1) {\n    var diff = TimeNow() - this.ts,\n        t = this.tc,\n        ga = t.pulsateTo + (1 - t.pulsateTo) * (0.5 + cos(2 * Math.PI * diff / (1000 * t.pulsateTime)) / 2);\n    this.pulse = ga = TagCanvas.Smooth(1, ga);\n    return this.DrawSimple(c, tag, x1, y1, ga, 1);\n  };\n\n  Oproto.Active = function (c, x, y) {\n    var a = x >= this.x && y >= this.y && x <= this.x + this.w && y <= this.y + this.h;\n\n    if (a) {\n      this.ts = this.ts || TimeNow();\n    } else {\n      this.ts = null;\n    }\n\n    return a;\n  };\n\n  Oproto.PreDraw = Oproto.PostDraw = Oproto.LastDraw = Nop;\n  /**\n   * @constructor\n   */\n\n  function Tag(tc, text, a, v, w, h, col, bcol, bradius, boutline, bothickness, font, padding, original) {\n    this.tc = tc;\n    this.image = null;\n    this.text = text;\n    this.text_original = original;\n    this.line_widths = [];\n    this.title = a.title || null;\n    this.a = a;\n    this.position = new Vector(v[0], v[1], v[2]);\n    this.x = this.y = this.z = 0;\n    this.w = w;\n    this.h = h;\n    this.colour = col || tc.textColour;\n    this.bgColour = bcol || tc.bgColour;\n    this.bgRadius = bradius | 0;\n    this.bgOutline = boutline || this.colour;\n    this.bgOutlineThickness = bothickness | 0;\n    this.textFont = font || tc.textFont;\n    this.padding = padding | 0;\n    this.sc = this.alpha = 1;\n    this.weighted = !tc.weight;\n    this.outline = new Outline(tc, this);\n  }\n\n  Tproto = Tag.prototype;\n\n  Tproto.Init = function (e) {\n    var tc = this.tc;\n    this.textHeight = tc.textHeight;\n\n    if (this.HasText()) {\n      this.Measure(tc.ctxt, tc);\n    } else {\n      this.w = this.iw;\n      this.h = this.ih;\n    }\n\n    this.SetShadowColour = tc.shadowAlpha ? this.SetShadowColourAlpha : this.SetShadowColourFixed;\n    this.SetDraw(tc);\n  };\n\n  Tproto.Draw = Nop;\n\n  Tproto.HasText = function () {\n    return this.text && this.text[0].length > 0;\n  };\n\n  Tproto.EqualTo = function (e) {\n    var i = e.getElementsByTagName('img');\n    if (this.a.href != e.href) return 0;\n    if (i.length) return this.image.src == i[0].src;\n    return (e.innerText || e.textContent) == this.text_original;\n  };\n\n  Tproto.SetImage = function (i) {\n    this.image = this.fimage = i;\n  };\n\n  Tproto.SetDraw = function (t) {\n    this.Draw = this.fimage ? t.ie > 7 ? this.DrawImageIE : this.DrawImage : this.DrawText;\n    t.noSelect && (this.CheckActive = Nop);\n  };\n\n  Tproto.MeasureText = function (c) {\n    var i,\n        l = this.text.length,\n        w = 0,\n        wl;\n\n    for (i = 0; i < l; ++i) {\n      this.line_widths[i] = wl = c.measureText(this.text[i]).width;\n      w = max(w, wl);\n    }\n\n    return w;\n  };\n\n  Tproto.Measure = function (c, t) {\n    var extents = FindTextBoundingBox(this.text, this.textFont, this.textHeight),\n        s,\n        th,\n        f,\n        soff,\n        cw,\n        twidth,\n        theight,\n        img,\n        tcv; // add the gap at the top to the height to make equal gap at bottom\n\n    theight = extents ? extents.max.y + extents.min.y : this.textHeight;\n    c.font = this.font = this.textHeight + 'px ' + this.textFont;\n    twidth = this.MeasureText(c);\n\n    if (t.txtOpt) {\n      s = t.txtScale;\n      th = s * this.textHeight;\n      f = th + 'px ' + this.textFont;\n      soff = [s * t.shadowOffset[0], s * t.shadowOffset[1]];\n      c.font = f;\n      cw = this.MeasureText(c);\n      tcv = new TextCanvas(this.text, f, cw + s, s * theight + s, cw, this.line_widths, t.textAlign, t.textVAlign, s);\n      if (this.image) tcv.SetImage(this.image, this.iw, this.ih, t.imagePosition, t.imagePadding, t.imageAlign, t.imageVAlign, t.imageScale);\n      img = tcv.Create(this.colour, this.bgColour, this.bgOutline, s * this.bgOutlineThickness, t.shadow, s * t.shadowBlur, soff, s * this.padding, s * this.bgRadius); // add outline image using highlight colour\n\n      if (t.outlineMethod == 'colour') {\n        this.oimage = tcv.Create(this.outline.colour, this.bgColour, this.outline.colour, s * this.bgOutlineThickness, t.shadow, s * t.shadowBlur, soff, s * this.padding, s * this.bgRadius);\n      } else if (t.outlineMethod == 'size') {\n        extents = FindTextBoundingBox(this.text, this.textFont, this.textHeight + t.outlineIncrease);\n        th = extents.max.y + extents.min.y;\n        f = s * (this.textHeight + t.outlineIncrease) + 'px ' + this.textFont;\n        c.font = f;\n        cw = this.MeasureText(c);\n        tcv = new TextCanvas(this.text, f, cw + s, s * th + s, cw, this.line_widths, t.textAlign, t.textVAlign, s);\n        if (this.image) tcv.SetImage(this.image, this.iw + t.outlineIncrease, this.ih + t.outlineIncrease, t.imagePosition, t.imagePadding, t.imageAlign, t.imageVAlign, t.imageScale);\n        this.oimage = tcv.Create(this.colour, this.bgColour, this.bgOutline, s * this.bgOutlineThickness, t.shadow, s * t.shadowBlur, soff, s * this.padding, s * this.bgRadius);\n        this.oscale = this.oimage.width / img.width;\n        if (t.outlineIncrease > 0) img = ExpandImage(img, this.oimage.width, this.oimage.height);else this.oimage = ExpandImage(this.oimage, img.width, img.height);\n      }\n\n      if (img) {\n        this.fimage = img;\n        twidth = this.fimage.width / s;\n        theight = this.fimage.height / s;\n      }\n\n      this.SetDraw(t);\n      t.txtOpt = !!this.fimage;\n    }\n\n    this.h = theight;\n    this.w = twidth;\n  };\n\n  Tproto.SetFont = function (f, c, bc, boc) {\n    this.textFont = f;\n    this.colour = c;\n    this.bgColour = bc;\n    this.bgOutline = boc;\n    this.Measure(this.tc.ctxt, this.tc);\n  };\n\n  Tproto.SetWeight = function (w) {\n    var tc = this.tc,\n        modes = tc.weightMode.split(/[, ]/),\n        m,\n        s,\n        wl = w.length;\n    if (!this.HasText()) return;\n    this.weighted = true;\n\n    for (s = 0; s < wl; ++s) {\n      m = modes[s] || 'size';\n\n      if ('both' == m) {\n        this.Weight(w[s], tc.ctxt, tc, 'size', tc.min_weight[s], tc.max_weight[s], s);\n        this.Weight(w[s], tc.ctxt, tc, 'colour', tc.min_weight[s], tc.max_weight[s], s);\n      } else {\n        this.Weight(w[s], tc.ctxt, tc, m, tc.min_weight[s], tc.max_weight[s], s);\n      }\n    }\n\n    this.Measure(tc.ctxt, tc);\n  };\n\n  Tproto.Weight = function (w, c, t, m, wmin, wmax, wnum) {\n    w = isNaN(w) ? 1 : w;\n    var nweight = (w - wmin) / (wmax - wmin);\n    if ('colour' == m) this.colour = FindGradientColour(t, nweight, wnum);else if ('bgcolour' == m) this.bgColour = FindGradientColour(t, nweight, wnum);else if ('bgoutline' == m) this.bgOutline = FindGradientColour(t, nweight, wnum);else if ('outline' == m) this.outline.colour = FindGradientColour(t, nweight, wnum);else if ('size' == m) {\n      if (t.weightSizeMin > 0 && t.weightSizeMax > t.weightSizeMin) {\n        this.textHeight = t.weightSize * (t.weightSizeMin + (t.weightSizeMax - t.weightSizeMin) * nweight);\n      } else {\n        // min textHeight of 1\n        this.textHeight = max(1, w * t.weightSize);\n      }\n    }\n  };\n\n  Tproto.SetShadowColourFixed = function (c, s, a) {\n    c.shadowColor = s;\n  };\n\n  Tproto.SetShadowColourAlpha = function (c, s, a) {\n    c.shadowColor = SetAlpha(s, a);\n  };\n\n  Tproto.DrawText = function (c, xoff, yoff) {\n    var t = this.tc,\n        x = this.x,\n        y = this.y,\n        s = this.sc,\n        i,\n        xl;\n    c.globalAlpha = this.alpha;\n    c.fillStyle = this.colour;\n    t.shadow && this.SetShadowColour(c, t.shadow, this.alpha);\n    c.font = this.font;\n    x += xoff / s;\n    y += yoff / s - this.h / 2;\n\n    for (i = 0; i < this.text.length; ++i) {\n      xl = x;\n\n      if ('right' == t.textAlign) {\n        xl += this.w / 2 - this.line_widths[i];\n      } else if ('centre' == t.textAlign) {\n        xl -= this.line_widths[i] / 2;\n      } else {\n        xl -= this.w / 2;\n      }\n\n      c.setTransform(s, 0, 0, s, s * xl, s * y);\n      c.fillText(this.text[i], 0, 0);\n      y += this.textHeight;\n    }\n  };\n\n  Tproto.DrawImage = function (c, xoff, yoff, im) {\n    var x = this.x,\n        y = this.y,\n        s = this.sc,\n        i = im || this.fimage,\n        w = this.w,\n        h = this.h,\n        a = this.alpha,\n        shadow = this.shadow;\n    c.globalAlpha = a;\n    shadow && this.SetShadowColour(c, shadow, a);\n    x += xoff / s - w / 2;\n    y += yoff / s - h / 2;\n    c.setTransform(s, 0, 0, s, s * x, s * y);\n    c.drawImage(i, 0, 0, w, h);\n  };\n\n  Tproto.DrawImageIE = function (c, xoff, yoff) {\n    var i = this.fimage,\n        s = this.sc,\n        w = i.width = this.w * s,\n        h = i.height = this.h * s,\n        x = this.x * s + xoff - w / 2,\n        y = this.y * s + yoff - h / 2;\n    c.setTransform(1, 0, 0, 1, 0, 0);\n    c.globalAlpha = this.alpha;\n    c.drawImage(i, x, y);\n  };\n\n  Tproto.Calc = function (m, a) {\n    var pp,\n        t = this.tc,\n        mnb = t.minBrightness,\n        mxb = t.maxBrightness,\n        r = t.max_radius;\n    pp = m.xform(this.position);\n    this.xformed = pp;\n    pp = Project(t, pp, t.stretchX, t.stretchY);\n    this.x = pp.x;\n    this.y = pp.y;\n    this.z = pp.z;\n    this.sc = pp.w;\n    this.alpha = a * Clamp(mnb + (mxb - mnb) * (r - this.z) / (2 * r), 0, 1);\n    return this.xformed;\n  };\n\n  Tproto.UpdateActive = function (c, xoff, yoff) {\n    var o = this.outline,\n        w = this.w,\n        h = this.h,\n        x = this.x - w / 2,\n        y = this.y - h / 2;\n    o.Update(x, y, w, h, this.sc, this.z, xoff, yoff);\n    return o;\n  };\n\n  Tproto.CheckActive = function (c, xoff, yoff) {\n    var t = this.tc,\n        o = this.UpdateActive(c, xoff, yoff);\n    return o.Active(c, t.mx, t.my) ? o : null;\n  };\n\n  Tproto.Clicked = function (e) {\n    var a = this.a,\n        t = a.target,\n        h = a.href,\n        evt;\n\n    if (t != '' && t != '_self') {\n      if (self.frames[t]) {\n        self.frames[t].document.location = h;\n      } else {\n        try {\n          if (top.frames[t]) {\n            top.frames[t].document.location = h;\n            return;\n          }\n        } catch (err) {// different domain/port/protocol?\n        }\n\n        window.open(h, t);\n      }\n\n      return;\n    }\n\n    if (doc.createEvent) {\n      evt = doc.createEvent('MouseEvents');\n      evt.initMouseEvent('click', 1, 1, window, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);\n      if (!a.dispatchEvent(evt)) return;\n    } else if (a.fireEvent) {\n      if (!a.fireEvent('onclick')) return;\n    }\n\n    doc.location = h;\n  };\n  /**\n   * @constructor\n   */\n\n\n  function TagCanvas(cid, lctr, opt) {\n    var i,\n        p,\n        c = doc.getElementById(cid),\n        cp = ['id', 'class', 'innerHTML'],\n        raf;\n    if (!c) throw 0;\n\n    if (Defined(window.G_vmlCanvasManager)) {\n      c = window.G_vmlCanvasManager.initElement(c);\n      this.ie = parseFloat(navigator.appVersion.split('MSIE')[1]);\n    }\n\n    if (c && (!c.getContext || !c.getContext('2d').fillText)) {\n      p = doc.createElement('DIV');\n\n      for (i = 0; i < cp.length; ++i) p[cp[i]] = c[cp[i]];\n\n      c.parentNode.insertBefore(p, c);\n      c.parentNode.removeChild(c);\n      throw 0;\n    }\n\n    for (i in TagCanvas.options) this[i] = opt && Defined(opt[i]) ? opt[i] : Defined(TagCanvas[i]) ? TagCanvas[i] : TagCanvas.options[i];\n\n    this.canvas = c;\n    this.ctxt = c.getContext('2d');\n    this.z1 = 250 / max(this.depth, 0.001);\n    this.z2 = this.z1 / this.zoom;\n    this.radius = min(c.height, c.width) * 0.0075; // fits radius of 100 in canvas\n\n    this.max_radius = 100;\n    this.max_weight = [];\n    this.min_weight = [];\n    this.textFont = this.textFont && FixFont(this.textFont);\n    this.textHeight *= 1;\n    this.imageRadius = this.imageRadius.toString();\n    this.pulsateTo = Clamp(this.pulsateTo, 0, 1);\n    this.minBrightness = Clamp(this.minBrightness, 0, 1);\n    this.maxBrightness = Clamp(this.maxBrightness, this.minBrightness, 1);\n    this.ctxt.textBaseline = 'top';\n    this.lx = (this.lock + '').indexOf('x') + 1;\n    this.ly = (this.lock + '').indexOf('y') + 1;\n    this.frozen = this.dx = this.dy = this.fixedAnim = this.touchState = 0;\n    this.fixedAlpha = 1;\n    this.source = lctr || cid;\n    this.repeatTags = min(64, ~~this.repeatTags);\n    this.minTags = min(200, ~~this.minTags);\n    if (~~this.scrollPause > 0) TagCanvas.scrollPause = ~~this.scrollPause;else this.scrollPause = 0;\n    if (this.minTags > 0 && this.repeatTags < 1 && (i = this.GetTags().length)) this.repeatTags = ceil(this.minTags / i) - 1;\n    this.transform = Matrix.Identity();\n    this.startTime = this.time = TimeNow();\n    this.mx = this.my = -1;\n    this.centreImage && CentreImage(this);\n    this.Animate = this.dragControl ? this.AnimateDrag : this.AnimatePosition;\n    this.animTiming = typeof TagCanvas[this.animTiming] == 'function' ? TagCanvas[this.animTiming] : TagCanvas.Smooth;\n\n    if (this.shadowBlur || this.shadowOffset[0] || this.shadowOffset[1]) {\n      // let the browser translate \"red\" into \"#ff0000\"\n      this.ctxt.shadowColor = this.shadow;\n      this.shadow = this.ctxt.shadowColor;\n      this.shadowAlpha = ShadowAlphaBroken();\n    } else {\n      delete this.shadow;\n    }\n\n    this.Load();\n\n    if (lctr && this.hideTags) {\n      (function (t) {\n        if (TagCanvas.loaded) t.HideTags();else AddHandler('load', function () {\n          t.HideTags();\n        }, window);\n      })(this);\n    }\n\n    this.yaw = this.initial ? this.initial[0] * this.maxSpeed : 0;\n    this.pitch = this.initial ? this.initial[1] * this.maxSpeed : 0;\n\n    if (this.tooltip) {\n      this.ctitle = c.title;\n      c.title = '';\n\n      if (this.tooltip == 'native') {\n        this.Tooltip = this.TooltipNative;\n      } else {\n        this.Tooltip = this.TooltipDiv;\n\n        if (!this.ttdiv) {\n          this.ttdiv = doc.createElement('div');\n          this.ttdiv.className = this.tooltipClass;\n          this.ttdiv.style.position = 'absolute';\n          this.ttdiv.style.zIndex = c.style.zIndex + 1;\n          AddHandler('mouseover', function (e) {\n            e.target.style.display = 'none';\n          }, this.ttdiv);\n          doc.body.appendChild(this.ttdiv);\n        }\n      }\n    } else {\n      this.Tooltip = this.TooltipNone;\n    }\n\n    if (!this.noMouse && !handlers[cid]) {\n      handlers[cid] = [['mousemove', MouseMove], ['mouseout', MouseOut], ['mouseup', MouseUp], ['touchstart', TouchDown], ['touchend', TouchUp], ['touchcancel', TouchUp], ['touchmove', TouchMove]];\n\n      if (this.dragControl) {\n        handlers[cid].push(['mousedown', MouseDown]);\n        handlers[cid].push(['selectstart', Nop]);\n      }\n\n      if (this.wheelZoom) {\n        handlers[cid].push(['mousewheel', MouseWheel]);\n        handlers[cid].push(['DOMMouseScroll', MouseWheel]);\n      }\n\n      if (this.scrollPause) {\n        handlers[cid].push(['scroll', Scroll, window]);\n      }\n\n      for (i = 0; i < handlers[cid].length; ++i) {\n        p = handlers[cid][i];\n        AddHandler(p[0], p[1], p[2] ? p[2] : c);\n      }\n    }\n\n    if (!TagCanvas.started) {\n      raf = window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n      TagCanvas.NextFrame = raf ? TagCanvas.NextFrameRAF : TagCanvas.NextFrameTimeout;\n      TagCanvas.interval = this.interval;\n      TagCanvas.NextFrame(this.interval);\n      TagCanvas.started = 1;\n    }\n  }\n\n  TCproto = TagCanvas.prototype;\n\n  TCproto.SourceElements = function () {\n    if (doc.querySelectorAll) return doc.querySelectorAll('#' + this.source);\n    return [doc.getElementById(this.source)];\n  };\n\n  TCproto.HideTags = function () {\n    var el = this.SourceElements(),\n        i;\n\n    for (i = 0; i < el.length; ++i) el[i].style.display = 'none';\n  };\n\n  TCproto.GetTags = function () {\n    var el = this.SourceElements(),\n        etl,\n        tl = [],\n        i,\n        j,\n        k;\n\n    for (k = 0; k <= this.repeatTags; ++k) {\n      for (i = 0; i < el.length; ++i) {\n        etl = el[i].getElementsByTagName('a');\n\n        for (j = 0; j < etl.length; ++j) {\n          tl.push(etl[j]);\n        }\n      }\n    }\n\n    return tl;\n  };\n\n  TCproto.Message = function (text) {\n    var tl = [],\n        i,\n        p,\n        tc = text.split(''),\n        a,\n        t,\n        x,\n        z;\n\n    for (i = 0; i < tc.length; ++i) {\n      if (tc[i] != ' ') {\n        p = i - tc.length / 2;\n        a = doc.createElement('A');\n        a.href = '#';\n        a.innerText = tc[i];\n        x = 100 * sin(p / 9);\n        z = -100 * cos(p / 9);\n        t = new Tag(this, tc[i], a, [x, 0, z], 2, 18, '#000', '#fff', 0, 0, 0, 'monospace', 2, tc[i]);\n        t.Init();\n        tl.push(t);\n      }\n    }\n\n    return tl;\n  };\n\n  TCproto.CreateTag = function (e) {\n    var im,\n        i,\n        t,\n        txt,\n        ts,\n        font,\n        bc,\n        boc,\n        p = [0, 0, 0];\n\n    if ('text' != this.imageMode) {\n      im = e.getElementsByTagName('img');\n\n      if (im.length) {\n        i = new Image();\n        i.src = im[0].src;\n\n        if (!this.imageMode) {\n          t = new Tag(this, \"\", e, p, 0, 0);\n          t.SetImage(i); //t.Init();\n\n          AddImage(i, im[0], t, this);\n          return t;\n        }\n      }\n    }\n\n    if ('image' != this.imageMode) {\n      ts = new TextSplitter(e);\n      txt = ts.Lines();\n\n      if (!ts.Empty()) {\n        font = this.textFont || FixFont(GetProperty(e, 'font-family'));\n        if (this.splitWidth) txt = ts.SplitWidth(this.splitWidth, this.ctxt, font, this.textHeight);\n        bc = this.bgColour == 'tag' ? GetProperty(e, 'background-color') : this.bgColour;\n        boc = this.bgOutline == 'tag' ? GetProperty(e, 'color') : this.bgOutline;\n      } else {\n        ts = null;\n      }\n    }\n\n    if (ts || i) {\n      t = new Tag(this, txt, e, p, 2, this.textHeight + 2, this.textColour || GetProperty(e, 'color'), bc, this.bgRadius, boc, this.bgOutlineThickness, font, this.padding, ts && ts.original);\n\n      if (i) {\n        t.SetImage(i);\n        AddImage(i, im[0], t, this);\n      } else {\n        t.Init();\n      }\n\n      return t;\n    }\n  };\n\n  TCproto.UpdateTag = function (t, a) {\n    var colour = this.textColour || GetProperty(a, 'color'),\n        font = this.textFont || FixFont(GetProperty(a, 'font-family')),\n        bc = this.bgColour == 'tag' ? GetProperty(a, 'background-color') : this.bgColour,\n        boc = this.bgOutline == 'tag' ? GetProperty(a, 'color') : this.bgOutline;\n    t.a = a;\n    t.title = a.title;\n    if (t.colour != colour || t.textFont != font || t.bgColour != bc || t.bgOutline != boc) t.SetFont(font, colour, bc, boc);\n  };\n\n  TCproto.Weight = function (tl) {\n    var ll = tl.length,\n        w,\n        i,\n        s,\n        weights = [],\n        valid,\n        wfrom = this.weightFrom ? this.weightFrom.split(/[, ]/) : [null],\n        wl = wfrom.length;\n\n    for (i = 0; i < ll; ++i) {\n      weights[i] = [];\n\n      for (s = 0; s < wl; ++s) {\n        w = FindWeight(tl[i].a, wfrom[s], this.textHeight);\n        if (!this.max_weight[s] || w > this.max_weight[s]) this.max_weight[s] = w;\n        if (!this.min_weight[s] || w < this.min_weight[s]) this.min_weight[s] = w;\n        weights[i][s] = w;\n      }\n    }\n\n    for (s = 0; s < wl; ++s) {\n      if (this.max_weight[s] > this.min_weight[s]) valid = 1;\n    }\n\n    if (valid) {\n      for (i = 0; i < ll; ++i) {\n        tl[i].SetWeight(weights[i]);\n      }\n    }\n  };\n\n  TCproto.Load = function () {\n    var tl = this.GetTags(),\n        taglist = [],\n        shape,\n        t,\n        shapeArgs,\n        rx,\n        ry,\n        rz,\n        vl,\n        i,\n        tagmap = [],\n        pfuncs = {\n      sphere: PointsOnSphere,\n      vcylinder: PointsOnCylinderV,\n      hcylinder: PointsOnCylinderH,\n      vring: PointsOnRingV,\n      hring: PointsOnRingH\n    };\n\n    if (tl.length) {\n      tagmap.length = tl.length;\n\n      for (i = 0; i < tl.length; ++i) tagmap[i] = i;\n\n      this.shuffleTags && Shuffle(tagmap);\n      rx = 100 * this.radiusX;\n      ry = 100 * this.radiusY;\n      rz = 100 * this.radiusZ;\n      this.max_radius = max(rx, max(ry, rz));\n\n      for (i = 0; i < tl.length; ++i) {\n        t = this.CreateTag(tl[tagmap[i]]);\n        if (t) taglist.push(t);\n      }\n\n      this.weight && this.Weight(taglist, true);\n\n      if (this.shapeArgs) {\n        this.shapeArgs[0] = taglist.length;\n      } else {\n        shapeArgs = this.shape.toString().split(/[(),]/);\n        shape = shapeArgs.shift();\n        if (typeof window[shape] === 'function') this.shape = window[shape];else this.shape = pfuncs[shape] || pfuncs.sphere;\n        this.shapeArgs = [taglist.length, rx, ry, rz].concat(shapeArgs);\n      }\n\n      vl = this.shape.apply(this, this.shapeArgs);\n      this.listLength = taglist.length;\n\n      for (i = 0; i < taglist.length; ++i) taglist[i].position = new Vector(vl[i][0], vl[i][1], vl[i][2]);\n    }\n\n    if (this.noTagsMessage && !taglist.length) {\n      i = this.imageMode && this.imageMode != 'both' ? this.imageMode + ' ' : '';\n      taglist = this.Message('No ' + i + 'tags');\n    }\n\n    this.taglist = taglist;\n  };\n\n  TCproto.Update = function () {\n    var tl = this.GetTags(),\n        newlist = [],\n        taglist = this.taglist,\n        found,\n        added = [],\n        removed = [],\n        vl,\n        ol,\n        nl,\n        i,\n        j;\n    if (!this.shapeArgs) return this.Load();\n\n    if (tl.length) {\n      nl = this.listLength = tl.length;\n      ol = taglist.length; // copy existing list, populate \"removed\"\n\n      for (i = 0; i < ol; ++i) {\n        newlist.push(taglist[i]);\n        removed.push(i);\n      } // find added and removed tags\n\n\n      for (i = 0; i < nl; ++i) {\n        for (j = 0, found = 0; j < ol; ++j) {\n          if (taglist[j].EqualTo(tl[i])) {\n            this.UpdateTag(newlist[j], tl[i]);\n            found = removed[j] = -1;\n          }\n        }\n\n        if (!found) added.push(i);\n      } // clean out found tags from removed list\n\n\n      for (i = 0, j = 0; i < ol; ++i) {\n        if (removed[j] == -1) removed.splice(j, 1);else ++j;\n      } // insert new tags in gaps where old tags removed\n\n\n      if (removed.length) {\n        Shuffle(removed);\n\n        while (removed.length && added.length) {\n          i = removed.shift();\n          j = added.shift();\n          newlist[i] = this.CreateTag(tl[j]);\n        } // remove any more (in reverse order)\n\n\n        removed.sort(function (a, b) {\n          return a - b;\n        });\n\n        while (removed.length) {\n          newlist.splice(removed.pop(), 1);\n        }\n      } // add any extra tags\n\n\n      j = newlist.length / (added.length + 1);\n      i = 0;\n\n      while (added.length) {\n        newlist.splice(ceil(++i * j), 0, this.CreateTag(tl[added.shift()]));\n      } // assign correct positions to tags\n\n\n      this.shapeArgs[0] = nl = newlist.length;\n      vl = this.shape.apply(this, this.shapeArgs);\n\n      for (i = 0; i < nl; ++i) newlist[i].position = new Vector(vl[i][0], vl[i][1], vl[i][2]); // reweight tags\n\n\n      this.weight && this.Weight(newlist);\n    }\n\n    this.taglist = newlist;\n  };\n\n  TCproto.SetShadow = function (c) {\n    c.shadowBlur = this.shadowBlur;\n    c.shadowOffsetX = this.shadowOffset[0];\n    c.shadowOffsetY = this.shadowOffset[1];\n  };\n\n  TCproto.Draw = function (t) {\n    if (this.paused) return;\n    var cv = this.canvas,\n        cw = cv.width,\n        ch = cv.height,\n        max_sc = 0,\n        tdelta = (t - this.time) * TagCanvas.interval / 1000,\n        x = cw / 2 + this.offsetX,\n        y = ch / 2 + this.offsetY,\n        c = this.ctxt,\n        active,\n        a,\n        i,\n        aindex = -1,\n        tl = this.taglist,\n        l = tl.length,\n        frontsel = this.frontSelect,\n        centreDrawn = this.centreFunc == Nop,\n        fixed;\n    this.time = t;\n    if (this.frozen && this.drawn) return this.Animate(cw, ch, tdelta);\n    fixed = this.AnimateFixed();\n    c.setTransform(1, 0, 0, 1, 0, 0);\n\n    for (i = 0; i < l; ++i) tl[i].Calc(this.transform, this.fixedAlpha);\n\n    tl = SortList(tl, function (a, b) {\n      return b.z - a.z;\n    });\n\n    if (fixed && this.fixedAnim.active) {\n      active = this.fixedAnim.tag.UpdateActive(c, x, y);\n    } else {\n      this.active = null;\n\n      for (i = 0; i < l; ++i) {\n        a = this.mx >= 0 && this.my >= 0 && this.taglist[i].CheckActive(c, x, y);\n\n        if (a && a.sc > max_sc && (!frontsel || a.z <= 0)) {\n          active = a;\n          aindex = i;\n          active.tag = this.taglist[i];\n          max_sc = a.sc;\n        }\n      }\n\n      this.active = active;\n    }\n\n    this.txtOpt || this.shadow && this.SetShadow(c);\n    c.clearRect(0, 0, cw, ch);\n\n    for (i = 0; i < l; ++i) {\n      if (!centreDrawn && tl[i].z <= 0) {\n        // run the centreFunc if the next tag is at the front\n        try {\n          this.centreFunc(c, cw, ch, x, y);\n        } catch (e) {\n          alert(e); // don't run it again\n\n          this.centreFunc = Nop;\n        }\n\n        centreDrawn = true;\n      }\n\n      if (!(active && active.tag == tl[i] && active.PreDraw(c, tl[i], x, y))) tl[i].Draw(c, x, y);\n      active && active.tag == tl[i] && active.PostDraw(c);\n    }\n\n    if (this.freezeActive && active) {\n      this.Freeze();\n    } else {\n      this.UnFreeze();\n      this.drawn = l == this.listLength;\n    }\n\n    if (this.fixedCallback) {\n      this.fixedCallback(this, this.fixedCallbackTag);\n      this.fixedCallback = null;\n    }\n\n    fixed || this.Animate(cw, ch, tdelta);\n    active && active.LastDraw(c);\n    cv.style.cursor = active ? this.activeCursor : '';\n    this.Tooltip(active, this.taglist[aindex]);\n  };\n\n  TCproto.TooltipNone = function () {};\n\n  TCproto.TooltipNative = function (active, tag) {\n    if (active) this.canvas.title = tag && tag.title ? tag.title : '';else this.canvas.title = this.ctitle;\n  };\n\n  TCproto.SetTTDiv = function (title, tag) {\n    var tc = this,\n        s = tc.ttdiv.style;\n    if (title != tc.ttdiv.innerHTML) s.display = 'none';\n    tc.ttdiv.innerHTML = title;\n    tag && (tag.title = tc.ttdiv.innerHTML);\n\n    if (s.display == 'none' && !tc.tttimer) {\n      tc.tttimer = setTimeout(function () {\n        var p = AbsPos(tc.canvas.id);\n        s.display = 'block';\n        s.left = p.x + tc.mx + 'px';\n        s.top = p.y + tc.my + 24 + 'px';\n        tc.tttimer = null;\n      }, tc.tooltipDelay);\n    }\n  };\n\n  TCproto.TooltipDiv = function (active, tag) {\n    if (active && tag && tag.title) {\n      this.SetTTDiv(tag.title, tag);\n    } else if (!active && this.mx != -1 && this.my != -1 && this.ctitle.length) {\n      this.SetTTDiv(this.ctitle);\n    } else {\n      this.ttdiv.style.display = 'none';\n    }\n  };\n\n  TCproto.Transform = function (tc, p, y) {\n    if (p || y) {\n      var sp = sin(p),\n          cp = cos(p),\n          sy = sin(y),\n          cy = cos(y),\n          ym = new Matrix([cy, 0, sy, 0, 1, 0, -sy, 0, cy]),\n          pm = new Matrix([1, 0, 0, 0, cp, -sp, 0, sp, cp]);\n      tc.transform = tc.transform.mul(ym.mul(pm));\n    }\n  };\n\n  TCproto.AnimateFixed = function () {\n    var fa, t1, angle, m, d;\n\n    if (this.fadeIn) {\n      t1 = TimeNow() - this.startTime;\n\n      if (t1 >= this.fadeIn) {\n        this.fadeIn = 0;\n        this.fixedAlpha = 1;\n      } else {\n        this.fixedAlpha = t1 / this.fadeIn;\n      }\n    }\n\n    if (this.fixedAnim) {\n      if (!this.fixedAnim.transform) this.fixedAnim.transform = this.transform;\n      fa = this.fixedAnim, t1 = TimeNow() - fa.t0, angle = fa.angle, m, d = this.animTiming(fa.t, t1);\n      this.transform = fa.transform;\n\n      if (t1 >= fa.t) {\n        this.fixedCallbackTag = fa.tag;\n        this.fixedCallback = fa.cb;\n        this.fixedAnim = this.yaw = this.pitch = 0;\n      } else {\n        angle *= d;\n      }\n\n      m = Matrix.Rotation(angle, fa.axis);\n      this.transform = this.transform.mul(m);\n      return this.fixedAnim != 0;\n    }\n\n    return false;\n  };\n\n  TCproto.AnimatePosition = function (w, h, t) {\n    var tc = this,\n        x = tc.mx,\n        y = tc.my,\n        s,\n        r;\n\n    if (!tc.frozen && x >= 0 && y >= 0 && x < w && y < h) {\n      s = tc.maxSpeed, r = tc.reverse ? -1 : 1;\n      tc.lx || (tc.yaw = (x * 2 * s / w - s) * r * t);\n      tc.ly || (tc.pitch = (y * 2 * s / h - s) * -r * t);\n      tc.initial = null;\n    } else if (!tc.initial) {\n      if (tc.frozen && !tc.freezeDecel) tc.yaw = tc.pitch = 0;else tc.Decel(tc);\n    }\n\n    this.Transform(tc, tc.pitch, tc.yaw);\n  };\n\n  TCproto.AnimateDrag = function (w, h, t) {\n    var tc = this,\n        rs = 100 * t * tc.maxSpeed / tc.max_radius / tc.zoom;\n\n    if (tc.dx || tc.dy) {\n      tc.lx || (tc.yaw = tc.dx * rs / tc.stretchX);\n      tc.ly || (tc.pitch = tc.dy * -rs / tc.stretchY);\n      tc.dx = tc.dy = 0;\n      tc.initial = null;\n    } else if (!tc.initial) {\n      tc.Decel(tc);\n    }\n\n    this.Transform(tc, tc.pitch, tc.yaw);\n  };\n\n  TCproto.Freeze = function () {\n    if (!this.frozen) {\n      this.preFreeze = [this.yaw, this.pitch];\n      this.frozen = 1;\n      this.drawn = 0;\n    }\n  };\n\n  TCproto.UnFreeze = function () {\n    if (this.frozen) {\n      this.yaw = this.preFreeze[0];\n      this.pitch = this.preFreeze[1];\n      this.frozen = 0;\n    }\n  };\n\n  TCproto.Decel = function (tc) {\n    var s = tc.minSpeed,\n        ay = abs(tc.yaw),\n        ap = abs(tc.pitch);\n    if (!tc.lx && ay > s) tc.yaw = ay > tc.z0 ? tc.yaw * tc.decel : 0;\n    if (!tc.ly && ap > s) tc.pitch = ap > tc.z0 ? tc.pitch * tc.decel : 0;\n  };\n\n  TCproto.Zoom = function (r) {\n    this.z2 = this.z1 * (1 / r);\n    this.drawn = 0;\n  };\n\n  TCproto.Clicked = function (e) {\n    var a = this.active;\n\n    try {\n      if (a && a.tag) if (this.clickToFront === false || this.clickToFront === null) a.tag.Clicked(e);else this.TagToFront(a.tag, this.clickToFront, function () {\n        a.tag.Clicked(e);\n      }, true);\n    } catch (ex) {}\n  };\n\n  TCproto.Wheel = function (i) {\n    var z = this.zoom + this.zoomStep * (i ? 1 : -1);\n    this.zoom = min(this.zoomMax, max(this.zoomMin, z));\n    this.Zoom(this.zoom);\n  };\n\n  TCproto.BeginDrag = function (e) {\n    this.down = EventXY(e, this.canvas);\n    e.cancelBubble = true;\n    e.returnValue = false;\n    e.preventDefault && e.preventDefault();\n  };\n\n  TCproto.Drag = function (e, p) {\n    if (this.dragControl && this.down) {\n      var t2 = this.dragThreshold * this.dragThreshold,\n          dx = p.x - this.down.x,\n          dy = p.y - this.down.y;\n\n      if (this.dragging || dx * dx + dy * dy > t2) {\n        this.dx = dx;\n        this.dy = dy;\n        this.dragging = 1;\n        this.down = p;\n      }\n    }\n\n    return this.dragging;\n  };\n\n  TCproto.EndDrag = function () {\n    var res = this.dragging;\n    this.dragging = this.down = null;\n    return res;\n  };\n\n  function PinchDistance(e) {\n    var t1 = e.targetTouches[0],\n        t2 = e.targetTouches[1];\n    return sqrt(pow(t2.pageX - t1.pageX, 2) + pow(t2.pageY - t1.pageY, 2));\n  }\n\n  TCproto.BeginPinch = function (e) {\n    this.pinched = [PinchDistance(e), this.zoom];\n    e.preventDefault && e.preventDefault();\n  };\n\n  TCproto.Pinch = function (e) {\n    var z,\n        d,\n        p = this.pinched;\n    if (!p) return;\n    d = PinchDistance(e);\n    z = p[1] * d / p[0];\n    this.zoom = min(this.zoomMax, max(this.zoomMin, z));\n    this.Zoom(this.zoom);\n  };\n\n  TCproto.EndPinch = function (e) {\n    this.pinched = null;\n  };\n\n  TCproto.Pause = function () {\n    this.paused = true;\n  };\n\n  TCproto.Resume = function () {\n    this.paused = false;\n  };\n\n  TCproto.SetSpeed = function (i) {\n    this.initial = i;\n    this.yaw = i[0] * this.maxSpeed;\n    this.pitch = i[1] * this.maxSpeed;\n  };\n\n  TCproto.FindTag = function (t) {\n    if (!Defined(t)) return null;\n    Defined(t.index) && (t = t.index);\n    if (!IsObject(t)) return this.taglist[t];\n    var srch, tgt, i;\n    if (Defined(t.id)) srch = 'id', tgt = t.id;else if (Defined(t.text)) srch = 'innerText', tgt = t.text;\n\n    for (i = 0; i < this.taglist.length; ++i) if (this.taglist[i].a[srch] == tgt) return this.taglist[i];\n  };\n\n  TCproto.RotateTag = function (tag, lt, lg, time, callback, active) {\n    var t = tag.Calc(this.transform, 1),\n        v1 = new Vector(t.x, t.y, t.z),\n        v2 = MakeVector(lg, lt),\n        angle = v1.angle(v2),\n        u = v1.cross(v2).unit();\n\n    if (angle == 0) {\n      this.fixedCallbackTag = tag;\n      this.fixedCallback = callback;\n    } else {\n      this.fixedAnim = {\n        angle: -angle,\n        axis: u,\n        t: time,\n        t0: TimeNow(),\n        cb: callback,\n        tag: tag,\n        active: active\n      };\n    }\n  };\n\n  TCproto.TagToFront = function (tag, time, callback, active) {\n    this.RotateTag(tag, 0, 0, time, callback, active);\n  };\n\n  TagCanvas.Start = function (id, l, o) {\n    TagCanvas.Delete(id);\n    TagCanvas.tc[id] = new TagCanvas(id, l, o);\n  };\n\n  function tccall(f, id) {\n    TagCanvas.tc[id] && TagCanvas.tc[id][f]();\n  }\n\n  TagCanvas.Linear = function (t, t0) {\n    return t0 / t;\n  };\n\n  TagCanvas.Smooth = function (t, t0) {\n    return 0.5 - cos(t0 * Math.PI / t) / 2;\n  };\n\n  TagCanvas.Pause = function (id) {\n    tccall('Pause', id);\n  };\n\n  TagCanvas.Resume = function (id) {\n    tccall('Resume', id);\n  };\n\n  TagCanvas.Reload = function (id) {\n    tccall('Load', id);\n  };\n\n  TagCanvas.Update = function (id) {\n    tccall('Update', id);\n  };\n\n  TagCanvas.SetSpeed = function (id, speed) {\n    if (IsObject(speed) && TagCanvas.tc[id] && !isNaN(speed[0]) && !isNaN(speed[1])) {\n      TagCanvas.tc[id].SetSpeed(speed);\n      return true;\n    }\n\n    return false;\n  };\n\n  TagCanvas.TagToFront = function (id, options) {\n    if (!IsObject(options)) return false;\n    options.lat = options.lng = 0;\n    return TagCanvas.RotateTag(id, options);\n  };\n\n  TagCanvas.RotateTag = function (id, options) {\n    if (IsObject(options) && TagCanvas.tc[id]) {\n      if (isNaN(options.time)) options.time = 500;\n      var tt = TagCanvas.tc[id].FindTag(options);\n\n      if (tt) {\n        TagCanvas.tc[id].RotateTag(tt, options.lat, options.lng, options.time, options.callback, options.active);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  TagCanvas.Delete = function (id) {\n    var i, c;\n\n    if (handlers[id]) {\n      c = doc.getElementById(id);\n\n      if (c) {\n        for (i = 0; i < handlers[id].length; ++i) RemoveHandler(handlers[id][i][0], handlers[id][i][1], c);\n      }\n    }\n\n    delete handlers[id];\n    delete TagCanvas.tc[id];\n  };\n\n  TagCanvas.NextFrameRAF = function () {\n    requestAnimationFrame(DrawCanvasRAF);\n  };\n\n  TagCanvas.NextFrameTimeout = function (iv) {\n    setTimeout(DrawCanvas, iv);\n  };\n\n  TagCanvas.tc = {};\n  TagCanvas.options = {\n    z1: 20000,\n    z2: 20000,\n    z0: 0.0002,\n    freezeActive: false,\n    freezeDecel: false,\n    activeCursor: 'pointer',\n    pulsateTo: 1,\n    pulsateTime: 3,\n    reverse: false,\n    depth: 0.5,\n    maxSpeed: 0.05,\n    minSpeed: 0,\n    decel: 0.95,\n    interval: 20,\n    minBrightness: 0.1,\n    maxBrightness: 1,\n    outlineColour: '#ffff99',\n    outlineThickness: 2,\n    outlineOffset: 5,\n    outlineMethod: 'outline',\n    outlineRadius: 0,\n    textColour: '#ff99ff',\n    textHeight: 15,\n    textFont: 'Helvetica, Arial, sans-serif',\n    shadow: '#000',\n    shadowBlur: 0,\n    shadowOffset: [0, 0],\n    initial: null,\n    hideTags: true,\n    zoom: 1,\n    weight: false,\n    weightMode: 'size',\n    weightFrom: null,\n    weightSize: 1,\n    weightSizeMin: null,\n    weightSizeMax: null,\n    weightGradient: {\n      0: '#f00',\n      0.33: '#ff0',\n      0.66: '#0f0',\n      1: '#00f'\n    },\n    txtOpt: true,\n    txtScale: 2,\n    frontSelect: false,\n    wheelZoom: true,\n    zoomMin: 0.3,\n    zoomMax: 3,\n    zoomStep: 0.05,\n    shape: 'sphere',\n    lock: null,\n    tooltip: null,\n    tooltipDelay: 300,\n    tooltipClass: 'tctooltip',\n    radiusX: 1,\n    radiusY: 1,\n    radiusZ: 1,\n    stretchX: 1,\n    stretchY: 1,\n    offsetX: 0,\n    offsetY: 0,\n    shuffleTags: false,\n    noSelect: false,\n    noMouse: false,\n    imageScale: 1,\n    paused: false,\n    dragControl: false,\n    dragThreshold: 4,\n    centreFunc: Nop,\n    splitWidth: 0,\n    animTiming: 'Smooth',\n    clickToFront: false,\n    fadeIn: 0,\n    padding: 0,\n    bgColour: null,\n    bgRadius: 0,\n    bgOutline: null,\n    bgOutlineThickness: 0,\n    outlineIncrease: 4,\n    textAlign: 'centre',\n    textVAlign: 'middle',\n    imageMode: null,\n    imagePosition: null,\n    imagePadding: 2,\n    imageAlign: 'centre',\n    imageVAlign: 'middle',\n    noTagsMessage: true,\n    centreImage: null,\n    pinchZoom: false,\n    repeatTags: 0,\n    minTags: 0,\n    imageRadius: 0,\n    scrollPause: false,\n    outlineDash: 0,\n    outlineDashSpace: 0,\n    outlineDashSpeed: 1\n  };\n\n  for (i in TagCanvas.options) TagCanvas[i] = TagCanvas.options[i];\n\n  window.TagCanvas = TagCanvas; // set a flag for when the window has loaded\n\n  AddHandler('load', function () {\n    TagCanvas.loaded = 1;\n  }, window);\n})();","map":null,"metadata":{},"sourceType":"script"}