{"ast":null,"code":"export default ((node, opts) => {\n  const wrapper = document.createElement(opts.tag);\n  /* Assign the element a class of \"blast\". */\n\n  wrapper.className = opts.name;\n  /* If a custom class was provided, assign that too. */\n\n  if (opts.customClass) {\n    wrapper.className += ' ' + opts.customClass;\n    /* If an opts.customClass is provided, generate an ID consisting of customClass and a number indicating the match's iteration. */\n\n    if (opts.generateIndexID) {\n      wrapper.id = opts.customClass + \"-\" + Element.blastedIndex;\n    }\n  }\n  /* For the \"all\" delimiter, prevent space characters from collapsing. */\n\n\n  if (opts.delimiter === \"all\" && /\\s/.test(node.data)) {\n    wrapper.style.whiteSpace = \"pre-line\";\n  }\n  /* Assign the element a class equal to its escaped inner text. Only applicable to the character and word delimiters (since they do not contain spaces). */\n\n\n  if (opts.generateValueClass === true && !opts.search && (opts.delimiter === \"character\" || opts.delimiter === \"word\")) {\n    var valueClass,\n        text = node.data;\n    /* For the word delimiter, remove adjoined punctuation, which is unlikely to be desired as part of the match -- unless the text\n       consists solely of punctuation (e.g. \"!!!\"), in which case we leave the text as-is. */\n\n    if (opts.delimiter === \"word\" && Reg.onlyContainsPunctuation.test(text)) {\n      /* E: Remove punctuation that's adjoined to either side of the word match. */\n      text = text.replace(Reg.adjoinedPunctuation, \"\");\n    }\n\n    valueClass = NAME + \"-\" + opts.delimiter.toLowerCase() + \"-\" + text.toLowerCase();\n    wrapper.className += \" \" + valueClass;\n  }\n  /* Hide the wrapper elements from screenreaders now that we've set the target's aria-label attribute. */\n\n\n  if (opts.aria) {\n    wrapper.setAttribute(\"aria-hidden\", \"true\");\n  }\n\n  wrapper.appendChild(node.cloneNode(false));\n  return wrapper;\n});","map":null,"metadata":{},"sourceType":"module"}